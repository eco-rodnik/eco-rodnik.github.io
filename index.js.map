{"version":3,"file":"index.js","sources":["../node_modules/endorphin/runtime/runtime.es.js","../src/router.ts","../src/topics.ts","../src/store.ts","../src/components/rod-logo/rod-logo.html","../src/components/rod-title/rod-title.html","../src/components/rod-menu/rod-menu.html","../src/components/rod-page/rod-page.html","../src/components/rod-news-item/rod-news-item.html","../src/components/rod-news-item/rod-news-item.ts","../src/components/rod-news-list/rod-news-list.html","../src/components/rod-page-main/rod-page-main.html","../src/components/rod-documents/rod-documents.html","../src/components/rod-page-about/rod-page-about.html","../src/components/rod-page-events/rod-page-events.html","../src/components/rod-page-news/rod-page-news.html","../src/components/rod-page-support/rod-page-support.html","../src/components/rod-page-contacts/rod-page-contacts.html","../src/components/rod-page-topic/rod-page-topic.ts","../src/components/rod-page-topic/rod-page-topic.html","../src/index.ts","../src/components/rod-app/rod-app.html"],"sourcesContent":["/**\n * Shorthand for `elem.appendChild()` for better minification\n */\nfunction appendChild(element, node) {\n    return element.appendChild(node);\n}\n/**\n * Creates element with given tag name\n * @param cssScope Scope for CSS isolation\n */\nfunction elem(tagName, cssScope) {\n    const el = document.createElement(tagName);\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Creates element with given tag name under `ns` namespace\n * @param cssScope Scope for CSS isolation\n */\nfunction elemNS(tagName, ns, cssScope) {\n    const el = document.createElementNS(ns, tagName);\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Creates element with given tag name and text\n * @param cssScope Scope for CSS isolation\n */\nfunction elemWithText(tagName, value, cssScope) {\n    const el = elem(tagName, cssScope);\n    el.appendChild(textNode(value));\n    return el;\n}\n/**\n * Creates element with given tag name under `ns` namespace and text\n * @param cssScope Scope for CSS isolation\n */\nfunction elemNSWithText(tagName, ns, value, cssScope) {\n    const el = elemNS(tagName, ns, cssScope);\n    el.appendChild(textNode(value));\n    return el;\n}\n/**\n * Creates text node with given value\n */\nfunction text(value) {\n    const node = textNode(value);\n    node.$value = value;\n    return node;\n}\n/**\n * Creates text node with given value\n */\nfunction textNode(value) {\n    return document.createTextNode(value != null ? value : '');\n}\n/**\n * Updates given text node value, if required\n * @returns Returns `1` if text was updated, `0` otherwise\n */\nfunction updateText(node, value) {\n    if (value !== node.$value) {\n        // node.nodeValue = textValue(value);\n        node.nodeValue = value != null ? value : '';\n        node.$value = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Isolates given element with CSS scope\n */\nfunction isolateElement(el, cssScope) {\n    el.setAttribute(cssScope, '');\n    return el;\n}\n/**\n * @returns Inserted item\n */\nfunction domInsert(node, parent, anchor) {\n    return anchor\n        ? parent.insertBefore(node, anchor)\n        : parent.appendChild(node);\n}\n/**\n * Removes given DOM node from its tree\n * @param {Node} node\n */\nfunction domRemove(node) {\n    const { parentNode } = node;\n    parentNode && parentNode.removeChild(node);\n}\n/**\n * Returns textual representation of given `value` object\n */\n// function textValue(value: any): string {\n// \treturn value != null ? value : '';\n// }\n\nconst animatingKey = '$$animating';\n/**\n * Creates fast object\n */\nfunction obj(proto = null) {\n    return Object.create(proto);\n}\n/**\n * Check if given value id defined, e.g. not `null`, `undefined` or `NaN`\n */\nfunction isDefined(value) {\n    return value != null && value === value;\n}\n/**\n * Returns properties from `next` which were changed since `prev` state.\n * Returns `null` if there are no changes\n */\nfunction changed(next, prev, prefix = '') {\n    const result = obj();\n    let dirty = false;\n    // Check if data was actually changed\n    for (const p in next) {\n        if (prev[p] !== next[p]) {\n            dirty = true;\n            result[prefix ? prefix + p : p] = {\n                prev: prev[p],\n                current: next[p]\n            };\n        }\n    }\n    return dirty ? result : null;\n}\n// tslint:disable-next-line:only-arrow-functions\nconst assign = Object.assign || function (target) {\n    for (let i = 1, source; i < arguments.length; i++) {\n        source = arguments[i];\n        for (const p in source) {\n            if (source.hasOwnProperty(p)) {\n                target[p] = source[p];\n            }\n        }\n    }\n    return target;\n};\n/**\n * Returns property descriptors from given object\n */\n// tslint:disable-next-line:only-arrow-functions\nconst getObjectDescriptors = Object['getOwnPropertyDescriptors'] || function (source) {\n    const descriptors = obj();\n    const props = Object.getOwnPropertyNames(source);\n    for (let i = 0, prop, descriptor; i < props.length; i++) {\n        prop = props[i];\n        descriptor = Object.getOwnPropertyDescriptor(source, prop);\n        if (descriptor != null) {\n            descriptors[prop] = descriptor;\n        }\n    }\n    return descriptors;\n};\nfunction safeCall(fn, arg1, arg2) {\n    try {\n        return fn && fn(arg1, arg2);\n    }\n    catch (err) {\n        // tslint:disable-next-line:no-console\n        console.error(err);\n    }\n}\nfunction captureError(host, fn, arg1, arg2) {\n    try {\n        return fn && fn(arg1, arg2);\n    }\n    catch (error) {\n        runtimeError(host, error);\n        // tslint:disable-next-line:no-console\n        console.error(error);\n    }\n}\nfunction runtimeError(host, error) {\n    if (typeof CustomEvent !== 'undefined') {\n        host.dispatchEvent(new CustomEvent('runtime-error', {\n            bubbles: true,\n            cancelable: true,\n            detail: { error, host }\n        }));\n    }\n    else {\n        throw error;\n    }\n}\n\n/**\n * Registers given event listener on `target` element and returns event binding\n * object to unregister event\n */\nfunction addEvent(target, type, listener, host, scope) {\n    return registerBinding(type, { host, scope, target, listener, handleEvent });\n}\n/**\n * Unregister given event binding\n */\nfunction removeEvent(type, binding) {\n    binding.target.removeEventListener(type, binding);\n}\n/**\n * Creates structure for collecting pending events\n */\nfunction pendingEvents(host, target) {\n    return { host, target, events: obj() };\n}\nfunction setPendingEvent(pending, type, listener, scope) {\n    let binding = pending.events[type];\n    if (binding) {\n        binding.listener = listener;\n        binding.scope = scope;\n    }\n    else {\n        binding = pending.events[type] = addEvent(pending.target, type, listener, pending.host, scope);\n    }\n    binding.pending = listener;\n}\nfunction finalizePendingEvents(pending) {\n    // For event listeners, we should only bind or unbind events, depending\n    // on current listener value\n    const { events } = pending;\n    for (const type in events) {\n        const binding = events[type];\n        if (binding) {\n            if (!binding.pending) {\n                events[type] = removeEvent(type, binding);\n            }\n            binding.pending = void 0;\n        }\n    }\n}\nfunction detachPendingEvents(pending) {\n    const { events } = pending;\n    for (const type in events) {\n        const binding = events[type];\n        if (binding) {\n            removeEvent(type, binding);\n        }\n    }\n}\nfunction handleEvent(event) {\n    try {\n        this.listener && this.listener(this.host, event, this.target, this.scope);\n    }\n    catch (error) {\n        runtimeError(this.host, error);\n        // tslint:disable-next-line:no-console\n        console.error(error);\n    }\n}\nfunction safeEventListener(host, handler) {\n    // tslint:disable-next-line:only-arrow-functions\n    return function (event) {\n        try {\n            handler.call(this, event);\n        }\n        catch (error) {\n            runtimeError(host, error);\n            // tslint:disable-next-line:no-console\n            console.error(error);\n        }\n    };\n}\nfunction registerBinding(type, binding) {\n    binding.target.addEventListener(type, binding);\n    return binding;\n}\n\n/** Base object to create pending namespaced attribute set */\nconst nsProto = obj();\n/**\n * Create pending props change set\n */\nfunction propsSet(elem, initial) {\n    const base = obj(elem.componentModel.defaultProps);\n    return initial ? assign(base, initial) : base;\n}\n/**\n * Alias for `elem.setAttribute`\n */\nfunction setAttribute(elem, name, value) {\n    elem.setAttribute(name, value);\n    return value;\n}\n/**\n * Updates element’s `name` attribute value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateAttribute(elem, prev, name, value) {\n    if (value !== prev[name]) {\n        const primitive = representedValue(value);\n        if (primitive === null) {\n            elem.removeAttribute(name);\n        }\n        else {\n            setAttribute(elem, name, primitive);\n        }\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Alias for `elem.className`\n */\nfunction setClass(elem, value) {\n    elem.className = value;\n    return value;\n}\n/**\n * Shorthand to update class name, specific to Endorphin compiled code\n */\nfunction updateClass(elem, prev, value) {\n    return updateAttribute(elem, prev, 'class', value === '' ? undefined : value);\n}\n/**\n * Sets attribute value as expression. Unlike regular primitive attributes,\n * expression values must be represented, e.g. non-primitive values must be\n * converted to string representations. Also, expression resolved to `false`,\n * `null` or `undefined` will remove attribute from element\n */\nfunction setAttributeExpression(elem, name, value) {\n    const primitive = representedValue(value);\n    primitive === null\n        ? elem.removeAttribute(name)\n        : setAttribute(elem, name, primitive);\n    return value;\n}\n/**\n * Alias for `elem.setAttributeNS`\n */\nfunction setAttributeNS(elem, ns, name, value) {\n    elem.setAttributeNS(ns, name, value);\n    return value;\n}\n/**\n * Updates element’s `name` attribute value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateAttributeNS(elem, prevNS, ns, name, value) {\n    const prev = ns in prevNS ? prevNS[ns] : (prevNS[ns] = obj());\n    if (value !== prev[name]) {\n        const primitive = representedValue(value);\n        if (primitive === null) {\n            elem.removeAttributeNS(ns, name);\n        }\n        else {\n            setAttributeNS(elem, ns, name, primitive);\n        }\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Same as `setAttributeExpression()` but for namespaced attributes\n */\nfunction setAttributeExpressionNS(elem, ns, name, value) {\n    const primitive = representedValue(value);\n    primitive === null\n        ? elem.removeAttributeNS(ns, name)\n        : setAttributeNS(elem, ns, name, primitive);\n    return value;\n}\n/**\n * Sets pending namespaced attribute value which will be added to element later\n */\nfunction setPendingAttributeNS(attrs, ns, name, value) {\n    const map = pendingNS(attrs, ns);\n    map[name] = value;\n}\n/**\n * Updates pending `name` value only if given `value` is not null\n */\nfunction updatePendingAttribute(attrs, name, value) {\n    if (value != null) {\n        attrs[name] = value;\n    }\n}\n/**\n * Updates pending namespaced `name` value only if given `value` is not null\n */\nfunction updatePendingAttributeNS(attrs, ns, name, value) {\n    if (value != null) {\n        pendingNS(attrs, ns)[name] = value;\n    }\n}\n/**\n * Adds given class name to pending attribute set\n */\nfunction addPendingClass(data, className) {\n    if (className != null) {\n        const prev = data.class;\n        data.class = prev ? prev + ' ' + className : String(className);\n    }\n}\n/**\n * Adds given class name to pending attribute set if condition is truthy\n */\nfunction addPendingClassIf(data, className, condition) {\n    condition && addPendingClass(data, className);\n}\n/**\n * Finalizes pending attributes\n */\nfunction finalizeAttributes(elem, cur, prev) {\n    let updated = 0;\n    for (const key in cur) {\n        const curValue = cur[key];\n        if (isPendingNS(curValue)) {\n            // It’s a pending attribute set\n            const prevNS = pendingNS(prev, key);\n            for (const name in curValue) {\n                const curNS = curValue[name];\n                if (curNS !== prevNS[name]) {\n                    updated = 1;\n                    setAttributeExpressionNS(elem, key, name, curNS);\n                    prevNS[name] = curNS;\n                }\n                curValue[name] = null;\n            }\n        }\n        else {\n            if (curValue !== prev[key]) {\n                updated = 1;\n                if (key === 'class') {\n                    elem.className = classNames(curValue);\n                }\n                else {\n                    setAttributeExpression(elem, key, curValue);\n                }\n                prev[key] = curValue;\n            }\n            cur[key] = null;\n        }\n    }\n    return updated;\n}\n/**\n * Returns normalized list of class names from given string\n */\nfunction classNames(str) {\n    if (isDefined(str)) {\n        return String(str).split(/\\s+/).filter(uniqueClassFilter).join(' ');\n    }\n    return '';\n}\n/**\n * Returns value for <input> element\n */\nfunction inputValue(value) {\n    return value != null ? value : '';\n}\n/**\n * Updates element’s `name` property value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateProperty(elem, prev, name, value) {\n    if (value !== prev[name]) {\n        elem[name] = name === 'value' ? inputValue(value) : value;\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns represented attribute value for given data\n */\nfunction representedValue(value) {\n    if (value === false || !isDefined(value)) {\n        return null;\n    }\n    if (value === true) {\n        return '';\n    }\n    if (Array.isArray(value)) {\n        return '[]';\n    }\n    if (typeof value === 'function') {\n        return '𝑓';\n    }\n    if (typeof value === 'object') {\n        return '{}';\n    }\n    return value;\n}\n/**\n * Check if given object is a pending namespaced attribute set\n */\nfunction isPendingNS(data) {\n    return data != null && typeof data === 'object' && Object.getPrototypeOf(data) === nsProto;\n}\n/**\n * Ensures given attribute value map contains namespace map for given `ns` and\n * returns it\n */\nfunction pendingNS(attrs, ns) {\n    return ns in attrs ? attrs[ns] : (attrs[ns] = Object.create(nsProto));\n}\nfunction uniqueClassFilter(cl, index, arr) {\n    return cl ? arr.indexOf(cl) === index : false;\n}\n\n/**\n * Creates linted list\n */\n/**\n * Creates linked list item\n */\nfunction createListItem(value) {\n    return { value, next: null, prev: null };\n}\n/**\n * Prepends given value to linked list\n */\nfunction listPrependValue(list, value) {\n    const item = createListItem(value);\n    if (item.next = list.head) {\n        item.next.prev = item;\n    }\n    return list.head = item;\n}\n/**\n * Inserts given value after given `ref` item\n */\nfunction listInsertValueAfter(value, ref) {\n    const item = createListItem(value);\n    const { next } = ref;\n    ref.next = item;\n    item.prev = ref;\n    if (item.next = next) {\n        next.prev = item;\n    }\n    return item;\n}\n/**\n * Moves list fragment with `start` and `end` bounds right after `ref` item\n */\nfunction listMoveFragmentAfter(list, start, end, ref) {\n    listDetachFragment(list, start, end);\n    if (end.next = ref.next) {\n        end.next.prev = end;\n    }\n    ref.next = start;\n    start.prev = ref;\n}\n/**\n * Moves list fragment with `start` and `end` to list head\n */\nfunction listMoveFragmentFirst(list, start, end) {\n    listDetachFragment(list, start, end);\n    if (end.next = list.head) {\n        end.next.prev = end;\n    }\n    list.head = start;\n}\n/**\n * Detaches list fragment with `start` and `end` from list\n */\nfunction listDetachFragment(list, start, end) {\n    const { prev } = start;\n    const { next } = end;\n    if (prev) {\n        prev.next = next;\n    }\n    else {\n        list.head = next;\n    }\n    if (next) {\n        next.prev = prev;\n    }\n    start.prev = end.next = null;\n}\n\n/**\n * Creates injector instance for given target, if required\n */\nfunction createInjector(target) {\n    return {\n        parentNode: target,\n        head: null,\n        ptr: null,\n        // NB create `slots` placeholder to promote object to hidden class.\n        // Do not use any additional function argument for adding value to `slots`\n        // to reduce runtime checks and keep functions in monomorphic state\n        slots: null\n    };\n}\n/**\n * Inserts given node into current context\n */\nfunction insert(injector, node, slotName = '') {\n    const { slots, ptr } = injector;\n    const target = slots\n        ? getSlotContext(injector, slotName).element\n        : injector.parentNode;\n    domInsert(node, target, ptr ? getAnchorNode(ptr.next, target) : void 0);\n    injector.ptr = ptr ? listInsertValueAfter(node, ptr) : listPrependValue(injector, node);\n    return node;\n}\n/**\n * Injects given block\n */\nfunction injectBlock(injector, block) {\n    const { ptr } = injector;\n    if (ptr) {\n        block.end = listInsertValueAfter(block, ptr);\n        block.start = listInsertValueAfter(block, ptr);\n    }\n    else {\n        block.end = listPrependValue(injector, block);\n        block.start = listPrependValue(injector, block);\n    }\n    injector.ptr = block.end;\n    return block;\n}\n/**\n * Returns named slot context from given component input’s injector. If slot context\n * doesn’t exists, it will be created\n */\nfunction getSlotContext(injector, name) {\n    const slots = injector.slots;\n    return slots[name] || (slots[name] = createSlotContext(name));\n}\n/**\n * Empties content of given block\n * @param detached Empty block in detached state. Detached state means one of the\n * parent DOM element will be removed from document so there’s no need to detach\n * inner DOM elements\n */\nfunction emptyBlockContent(block, detached) {\n    const unmount = block.mount && block.mount.dispose;\n    if (unmount) {\n        unmount(block.scope, block.host);\n    }\n    let item = block.start.next;\n    while (item && item !== block.end) {\n        // tslint:disable-next-line:prefer-const\n        let { value, next, prev } = item;\n        if (!isElement(value)) {\n            next = value.end.next;\n            disposeBlock(value);\n        }\n        else if (!detached && !value[animatingKey]) {\n            domRemove(value);\n        }\n        // NB: Block always contains `.next` and `.prev` items which are block\n        // bounds so we can safely skip null check here\n        prev.next = next;\n        next.prev = prev;\n        item = next;\n    }\n}\n/**\n * Moves contents of `block` after `ref` list item\n */\nfunction move(injector, block, ref) {\n    if (ref && ref.next && ref.next.value === block) {\n        return;\n    }\n    // Update linked list\n    const { start, end } = block;\n    if (ref) {\n        listMoveFragmentAfter(injector, start, end, ref);\n    }\n    else {\n        listMoveFragmentFirst(injector, start, end);\n    }\n    // Move block contents in DOM\n    let item = start.next;\n    let node;\n    while (item && item !== end) {\n        if (isElement(item.value)) {\n            node = item.value;\n            // NB it’s possible that a single block contains nodes from different\n            // slots so we have to find anchor for each node individually\n            domInsert(node, node.parentNode, getAnchorNode(end.next, node.parentNode));\n        }\n        item = item.next;\n    }\n}\n/**\n * Disposes given block\n */\nfunction disposeBlock(block, detached) {\n    emptyBlockContent(block, detached);\n    listDetachFragment(block.injector, block.start, block.end);\n    // @ts-ignore: Nulling disposed object\n    block.start = block.end = block.scope = null;\n}\nfunction isElement(obj) {\n    return 'nodeType' in obj;\n}\n/**\n * Get DOM node nearest to given position of items list\n */\nfunction getAnchorNode(item, parent) {\n    while (item) {\n        if (item.value.parentNode === parent) {\n            return item.value;\n        }\n        item = item.next;\n    }\n}\n/**\n * Creates context for given slot\n */\nfunction createSlotContext(name) {\n    const element = document.createElement('slot');\n    name && element.setAttribute('name', name);\n    return {\n        name,\n        element,\n        isDefault: false,\n        defaultContent: null\n    };\n}\n\n/**\n * Invokes `name` hook for given component definition\n */\nfunction runHook(component, name, arg1, arg2) {\n    const { plugins } = component.componentModel;\n    for (let i = plugins.length - 1, hook; i >= 0; i--) {\n        hook = plugins[i][name];\n        if (typeof hook === 'function') {\n            try {\n                hook(component, arg1, arg2);\n            }\n            catch (error) {\n                runtimeError(component, error);\n                // tslint:disable-next-line:no-console\n                console.error(error);\n            }\n        }\n    }\n}\n\n/**\n * Enters new variable scope context\n */\nfunction enterScope(host, incoming) {\n    return setScope(host, createScope(host, incoming));\n}\n/**\n * Exit from current variable scope\n */\nfunction exitScope(host) {\n    return setScope(host, Object.getPrototypeOf(host.componentModel.vars));\n}\n/**\n * Creates new scope from given component state\n */\nfunction createScope(host, incoming) {\n    return assign(obj(host.componentModel.vars), incoming);\n}\n/**\n * Sets given object as current component scope\n */\nfunction setScope(host, scope) {\n    return host.componentModel.vars = scope;\n}\n/**\n * Returns current variable scope\n */\nfunction getScope(elem) {\n    return elem.componentModel.vars;\n}\n/**\n * Returns property with given name from component\n */\nfunction getProp(elem, name) {\n    return elem.props[name];\n}\n/**\n * Returns state value with given name from component\n */\nfunction getState(elem, name) {\n    return elem.state[name];\n}\n/**\n * Returns value of given runtime variable from component\n */\nfunction getVar(elem, name) {\n    return elem.componentModel.vars[name];\n}\n/**\n * Sets value of given runtime variable for component\n */\nfunction setVar(elem, name, value) {\n    elem.componentModel.vars[name] = value;\n}\n\n/**\n * Creates slot element\n */\nfunction createSlot(host, name, cssScope) {\n    const el = getSlotContext(host.componentModel.input, name).element;\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Mounts slot context\n */\nfunction mountSlot(host, name, defaultContent) {\n    const { input } = host.componentModel;\n    const ctx = getSlotContext(input, name);\n    const injector = createInjector(ctx.element);\n    if (defaultContent) {\n        // Add block with default slot content\n        ctx.defaultContent = injectBlock(injector, {\n            host,\n            injector,\n            scope: getScope(host),\n            content: defaultContent,\n            mount: void 0,\n            update: void 0\n        });\n    }\n    if (isEmpty(ctx)) {\n        // No incoming content, mount default content\n        renderDefaultContent(ctx);\n    }\n    else {\n        setSlotted(ctx, true);\n    }\n    return ctx;\n}\n/**\n * Handles possible update of incoming data\n */\nfunction updateIncomingSlot(host, name, updated) {\n    const ctx = getSlotContext(host.componentModel.input, name);\n    if (updated) {\n        // Incoming content was updated but there’s default content mounted\n        if (ctx.isDefault) {\n            const block = ctx.defaultContent;\n            if (block) {\n                emptyBlockContent(block);\n                block.mount = void 0;\n            }\n            setSlotted(ctx, true);\n        }\n        notifySlotUpdate(host, ctx);\n    }\n    if (!ctx.isDefault && isEmpty(ctx)) {\n        // If slot content is empty, ensure default content is rendered\n        renderDefaultContent(ctx);\n    }\n}\n/**\n * Updates default slot content only if it was already rendered\n */\nfunction updateDefaultSlot(ctx) {\n    if (ctx.isDefault) {\n        const block = ctx.defaultContent;\n        if (block.update) {\n            block.update(block.host, block.scope);\n        }\n    }\n}\n/**\n * Unmounts default content of given slot context\n */\nfunction unmountSlot(ctx) {\n    const block = ctx.defaultContent;\n    if (block) {\n        disposeBlock(block);\n        setSlotted(ctx, false);\n        ctx.isDefault = false;\n        ctx.defaultContent = null;\n    }\n}\nfunction notifySlotUpdate(host, ctx) {\n    runHook(host, 'didSlotUpdate', ctx.name, ctx.element);\n}\n/**\n * Renders default slot content\n */\nfunction renderDefaultContent(ctx) {\n    if (ctx.defaultContent) {\n        const block = ctx.defaultContent;\n        const { injector } = block;\n        injector.ptr = block.start;\n        block.mount = block.content;\n        block.update = block.mount(block.host, injector, block.scope);\n        injector.ptr = block.end;\n    }\n    setSlotted(ctx, false);\n}\n/**\n * Check if given slot is empty\n */\nfunction isEmpty(ctx) {\n    // TODO better check for input content?\n    return !ctx.element.childNodes.length;\n}\n/**\n * Toggles slotted state in slot container\n */\nfunction setSlotted(ctx, slotted) {\n    ctx.isDefault = !slotted;\n    slotted ? ctx.element.setAttribute('slotted', '') : ctx.element.removeAttribute('slotted');\n}\n\nlet renderQueue = null;\n/** A lookup of normalized attributes */\nconst attributeLookup = {};\n/**\n * Creates Endorphin DOM component with given definition\n */\nfunction createComponent(name, definition, host) {\n    let cssScope;\n    let root;\n    if (host && 'componentModel' in host) {\n        cssScope = host.componentModel.definition.cssScope;\n        root = host.root || host;\n    }\n    const element = elem(name, cssScope);\n    return createComponentFromElement(element, definition, root);\n}\n/**\n * Convert HTMLElement into Endorphin DOM component with given definition\n */\nfunction createComponentFromElement(el, definition, root) {\n    const element = el;\n    // Add host scope marker: we can’t rely on tag name since component\n    // definition is bound to element in runtime, not compile time\n    if (definition.cssScope) {\n        element.setAttribute(definition.cssScope + '-host', '');\n    }\n    const { props, state, extend, events, plugins } = prepare(element, definition);\n    element.refs = obj();\n    element.props = obj();\n    element.state = state;\n    element.componentView = element; // XXX Should point to Shadow Root in Web Components\n    root && (element.root = root);\n    addPropsState(element);\n    if (extend) {\n        Object.defineProperties(element, extend);\n    }\n    if (definition.store) {\n        element.store = definition.store();\n    }\n    else if (root && root.store) {\n        element.store = root.store;\n    }\n    // Create slotted input\n    const input = createInjector(element.componentView);\n    input.slots = obj();\n    element.componentModel = {\n        definition,\n        input,\n        vars: obj(),\n        mounted: false,\n        preparing: false,\n        update: void 0,\n        queued: false,\n        events,\n        plugins,\n        partialDeps: null,\n        defaultProps: props\n    };\n    runHook(element, 'init');\n    return element;\n}\n/**\n * Mounts given component\n */\nfunction mountComponent(component, props) {\n    const { componentModel } = component;\n    const { input, definition } = componentModel;\n    const changes = setPropsInternal(component, props || componentModel.defaultProps);\n    const arg = changes || {};\n    componentModel.preparing = true;\n    // Notify slot status\n    for (const p in input.slots) {\n        notifySlotUpdate(component, input.slots[p]);\n    }\n    if (changes) {\n        runHook(component, 'didChange', arg);\n    }\n    runHook(component, 'willMount', arg);\n    runHook(component, 'willRender', arg);\n    componentModel.preparing = false;\n    componentModel.update = captureError(component, definition.default, component, getScope(component));\n    componentModel.mounted = true;\n    runHook(component, 'didRender', arg);\n    runHook(component, 'didMount', arg);\n}\n/**\n * Updates given mounted component\n */\nfunction updateComponent(component, props, partialDeps) {\n    const { componentModel } = component;\n    let changes = props && setPropsInternal(component, props);\n    if (partialDeps) {\n        if (!changes && partialDepsUpdated(componentModel.partialDeps, partialDeps)) {\n            changes = obj();\n        }\n        componentModel.partialDeps = partialDeps;\n    }\n    if (changes || componentModel.queued) {\n        renderNext(component, changes);\n    }\n    return changes ? 1 : 0;\n}\n/**\n * Destroys given component: removes static event listeners and cleans things up\n * @returns Should return nothing since function result will be used\n * as shorthand to reset cached value\n */\nfunction unmountComponent(component) {\n    const { componentModel } = component;\n    const { definition, events } = componentModel;\n    runHook(component, 'willUnmount');\n    componentModel.mounted = false;\n    if (events) {\n        detachStaticEvents(component, events);\n    }\n    if (component.store) {\n        component.store.unwatch(component);\n    }\n    const dispose = definition.default && definition.default.dispose;\n    captureError(component, dispose, getScope(component));\n    runHook(component, 'didUnmount');\n    // @ts-ignore: Nulling disposed object\n    component.componentModel = null;\n}\n/**\n * Subscribes to store updates of given component\n */\nfunction subscribeStore(component, keys) {\n    if (!component.store) {\n        throw new Error(`Store is not defined for ${component.nodeName} component`);\n    }\n    component.store.watch(component, keys);\n}\n/**\n * Queues next component render\n */\nfunction renderNext(component, changes) {\n    if (!component.componentModel.preparing) {\n        renderComponent(component, changes);\n    }\n    else {\n        scheduleRender(component, changes);\n    }\n}\n/**\n * Schedules render of given component on next tick\n */\nfunction scheduleRender(component, changes) {\n    if (!component.componentModel.queued) {\n        component.componentModel.queued = true;\n        if (renderQueue) {\n            renderQueue.push(component, changes);\n        }\n        else {\n            renderQueue = [component, changes];\n            requestAnimationFrame(drainQueue);\n        }\n    }\n}\n/**\n * Renders given component\n */\nfunction renderComponent(component, changes) {\n    const { componentModel } = component;\n    const arg = changes || {};\n    componentModel.queued = false;\n    componentModel.preparing = true;\n    if (changes) {\n        runHook(component, 'didChange', arg);\n    }\n    runHook(component, 'willUpdate', arg);\n    runHook(component, 'willRender', arg);\n    componentModel.preparing = false;\n    captureError(component, componentModel.update, component, getScope(component));\n    runHook(component, 'didRender', arg);\n    runHook(component, 'didUpdate', arg);\n}\n/**\n * Removes attached events from given map\n */\nfunction detachStaticEvents(component, eventMap) {\n    const { listeners, handler } = eventMap;\n    for (const p in listeners) {\n        component.removeEventListener(p, handler);\n    }\n}\nfunction kebabCase(ch) {\n    return '-' + ch.toLowerCase();\n}\nfunction setPropsInternal(component, nextProps) {\n    let changes;\n    const { props } = component;\n    const { defaultProps } = component.componentModel;\n    let prev;\n    let current;\n    for (const p in nextProps) {\n        prev = props[p];\n        current = nextProps[p];\n        if (current == null && p in defaultProps) {\n            current = defaultProps[p];\n        }\n        if (p === 'class' && current != null) {\n            current = classNames(current);\n        }\n        if (current !== prev) {\n            if (!changes) {\n                changes = obj();\n            }\n            props[p] = current;\n            changes[p] = { current, prev };\n            if (!/^partial:/.test(p)) {\n                setAttributeExpression(component, normalizeAttribute(p), current);\n            }\n        }\n    }\n    return changes;\n}\n/**\n * Check if `next` contains value that differs from one in `prev`\n */\nfunction hasChanges(prev, next) {\n    for (const p in next) {\n        if (next[p] !== prev[p]) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Prepares internal data for given component\n */\nfunction prepare(component, definition) {\n    const props = obj();\n    const state = obj();\n    const plugins = collectPlugins(component, definition, [definition]);\n    let events;\n    let extend;\n    for (let i = plugins.length - 1; i >= 0; i--) {\n        const dfn = plugins[i];\n        dfn.props && assign(props, dfn.props(component));\n        dfn.state && assign(state, dfn.state(component));\n        // NB: backward compatibility with previous implementation\n        if (dfn.methods) {\n            extend = getDescriptors(dfn.methods, extend);\n        }\n        if (dfn.extend) {\n            extend = getDescriptors(dfn.extend, extend);\n        }\n        if (dfn.events) {\n            if (!events) {\n                events = createEventsMap(component);\n            }\n            attachEventHandlers(component, dfn.events, events);\n        }\n    }\n    return { props, state, extend, events, plugins };\n}\n/**\n * Collects all plugins (including nested) into a flat list\n */\nfunction collectPlugins(component, definition, dest = []) {\n    let { plugins } = definition;\n    if (typeof plugins === 'function') {\n        plugins = plugins(component);\n    }\n    if (Array.isArray(plugins)) {\n        for (let i = 0; i < plugins.length; i++) {\n            dest.push(plugins[i]);\n            collectPlugins(component, plugins[i], dest);\n        }\n    }\n    return dest;\n}\n/**\n * Extracts property descriptors from given source object and merges it with `prev`\n * descriptor map, if given\n */\nfunction getDescriptors(source, prev) {\n    const descriptors = getObjectDescriptors(source);\n    return prev ? assign(prev, descriptors) : descriptors;\n}\nfunction createEventsMap(component) {\n    const listeners = obj();\n    const handler = function (evt) {\n        if (component.componentModel) {\n            const handlers = listeners[evt.type];\n            for (let i = 0; i < handlers.length; i++) {\n                handlers[i](component, evt, this);\n            }\n        }\n    };\n    return { handler: safeEventListener(component, handler), listeners };\n}\nfunction attachEventHandlers(component, events, eventMap) {\n    const names = Object.keys(events);\n    const { listeners } = eventMap;\n    for (let i = 0, name; i < names.length; i++) {\n        name = names[i];\n        if (name in listeners) {\n            listeners[name].push(events[name]);\n        }\n        else {\n            component.addEventListener(name, eventMap.handler);\n            listeners[name] = [events[name]];\n        }\n    }\n}\nfunction addPropsState(element) {\n    element.setProps = function setProps(value) {\n        const { componentModel } = element;\n        // In case of calling `setProps` after component was unmounted,\n        // check if `componentModel` is available\n        if (value != null && componentModel && componentModel.mounted) {\n            const changes = setPropsInternal(element, assign(obj(), value));\n            changes && renderNext(element, changes);\n            return changes;\n        }\n    };\n    element.setState = function setState(value) {\n        const { componentModel } = element;\n        // In case of calling `setState` after component was unmounted,\n        // check if `componentModel` is available\n        if (value != null && componentModel && hasChanges(element.state, value)) {\n            assign(element.state, value);\n            // If we’re in rendering state than current `setState()` is caused by\n            // one of the `will*` hooks, which means applied changes will be automatically\n            // applied during rendering stage.\n            // If called outside of rendering state we should schedule render\n            // on next tick\n            if (componentModel.mounted && !componentModel.preparing) {\n                scheduleRender(element);\n            }\n        }\n    };\n}\nfunction drainQueue() {\n    const pending = renderQueue;\n    renderQueue = null;\n    for (let i = 0, component; i < pending.length; i += 2) {\n        component = pending[i];\n        // It’s possible that a component can be rendered before next tick\n        // (for example, if parent node updated component props).\n        // Check if it’s still queued then render.\n        // Also, component can be unmounted after it’s rendering was scheduled\n        if (component.componentModel && component.componentModel.queued) {\n            renderComponent(component, pending[i + 1]);\n        }\n    }\n}\n/**\n * Normalizes given attribute name: converts `camelCase` to `kebab-case`\n */\nfunction normalizeAttribute(attr) {\n    if (!(attr in attributeLookup)) {\n        attributeLookup[attr] = attr.replace(/[A-Z]/g, kebabCase);\n    }\n    return attributeLookup[attr];\n}\n/**\n * Check if partial dependencies of component were updated\n */\nfunction partialDepsUpdated(prev, next) {\n    if (!prev) {\n        return true;\n    }\n    // In compiler, deps will always have the same length\n    for (let i = 0; i < prev.length; i++) {\n        if (prev[i] !== next[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction mountBlock(host, injector, get) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        mount: undefined,\n        update: undefined\n    });\n    updateBlock(block);\n    return block;\n}\n/**\n * Updated block, described in `ctx` object\n * @returns Returns `1` if block was updated, `0` otherwise\n */\nfunction updateBlock(block) {\n    let updated = 0;\n    const { host, injector, scope } = block;\n    const mount = block.get(host, scope);\n    if (block.mount !== mount) {\n        updated = 1;\n        // Unmount previously rendered content\n        block.mount && emptyBlockContent(block);\n        // Mount new block content\n        injector.ptr = block.start;\n        block.mount = mount;\n        block.update = mount && mount(block.host, injector, scope);\n    }\n    else if (block.update) {\n        // Update rendered result\n        updated = block.update(host, scope) ? 1 : 0;\n    }\n    block.injector.ptr = block.end;\n    return updated;\n}\nfunction unmountBlock(block) {\n    disposeBlock(block);\n}\nfunction clearBlock(block) {\n    disposeBlock(block, true);\n}\n\n/**\n * Mounts iterator block\n * @param get A function that returns collection to iterate\n * @param body A function that renders item of iterated collection\n */\nfunction mountIterator(host, injector, get, body) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        body,\n        index: 0,\n        updated: 0\n    });\n    updateIterator(block);\n    return block;\n}\n/**\n * Updates iterator block defined in `ctx`\n * @returns Returns `1` if iterator was updated, `0` otherwise\n */\nfunction updateIterator(block) {\n    const { injector } = block;\n    injector.ptr = block.start;\n    block.index = block.updated = 0;\n    const collection = block.get(block.host, block.scope);\n    if (collection && typeof collection.forEach === 'function') {\n        collection.forEach(iterator, block);\n    }\n    trimIteratorItems(block, injector.ptr.next);\n    injector.ptr = block.end;\n    return block.updated;\n}\nfunction unmountIterator(block) {\n    disposeBlock(block);\n}\nfunction clearIterator(block) {\n    disposeBlock(block, true);\n}\nfunction prepareScope(scope, index, key, value) {\n    scope.index = index;\n    scope.key = key;\n    scope.value = value;\n    return scope;\n}\n/**\n * Removes remaining iterator items from current context\n */\nfunction trimIteratorItems(block, start) {\n    let listItem;\n    while (start !== block.end) {\n        block.updated = 1;\n        listItem = start.value;\n        start = listItem.end.next;\n        disposeBlock(listItem);\n    }\n}\nfunction iterator(value, key) {\n    const { host, injector, index, body, end } = this;\n    const { next } = injector.ptr;\n    const prevScope = getScope(host);\n    let rendered;\n    if (next !== end) {\n        rendered = next.value;\n        // We have rendered item, update it\n        if (rendered.update) {\n            const scope = prepareScope(rendered.scope, index, key, value);\n            setScope(host, scope);\n            if (rendered.update(host, scope)) {\n                this.updated = 1;\n            }\n            setScope(host, prevScope);\n        }\n    }\n    else {\n        // Create & render new block\n        const scope = prepareScope(obj(prevScope), index, key, value);\n        rendered = injectBlock(injector, {\n            host,\n            injector,\n            scope,\n            mount: body,\n            update: undefined,\n        });\n        setScope(host, scope);\n        injector.ptr = rendered.start;\n        rendered.update = body(host, injector, scope);\n        setScope(host, prevScope);\n        this.updated = 1;\n    }\n    injector.ptr = rendered.end;\n    this.index++;\n}\n\n/**\n * Renders key iterator block\n */\nfunction mountKeyIterator(host, injector, get, keyExpr, body) {\n    const parentScope = getScope(host);\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: obj(parentScope),\n        get,\n        body,\n        keyExpr,\n        index: 0,\n        updated: 0,\n        used: null,\n        rendered: null,\n        needReorder: false,\n        parentScope,\n        order: []\n    });\n    updateKeyIterator(block);\n    return block;\n}\n/**\n * Updates iterator block defined in `ctx`\n * @returns Returns `1` if iterator was updated, `0` otherwise\n */\nfunction updateKeyIterator(block) {\n    const { host, injector, rendered } = block;\n    injector.ptr = block.start;\n    block.used = obj();\n    block.index = block.updated = 0;\n    block.needReorder = false;\n    const collection = block.get(host, block.parentScope);\n    if (collection && typeof collection.forEach === 'function') {\n        const prevScope = getScope(host);\n        collection.forEach(keyIterator, block);\n        setScope(host, prevScope);\n    }\n    if (rendered) {\n        block.updated |= disposeLookup(rendered);\n    }\n    if (block.needReorder) {\n        block.updated = 1;\n        reorder(block);\n    }\n    block.order.length = 0;\n    block.rendered = block.used;\n    injector.ptr = block.end;\n    return block.updated;\n}\nfunction unmountKeyIterator(block) {\n    disposeBlock(block);\n}\nfunction clearKeyIterator(block) {\n    disposeBlock(block, true);\n}\nfunction getItem(listItem, bound) {\n    return listItem !== bound ? listItem.value : null;\n}\nfunction keyIterator(value, key) {\n    const { injector, index, rendered } = this;\n    const id = this.keyExpr(value, prepareScope(this.scope, index, key, value));\n    let entry = rendered && getLookup(rendered, id);\n    if (entry) {\n        if (entry.start.prev !== injector.ptr) {\n            this.needReorder = true;\n        }\n        this.updated |= updateEntry(entry, value, key, index);\n    }\n    else {\n        entry = mountEntry(this, value, key, index);\n        this.updated = 1;\n    }\n    putLookup(this.used, id, entry);\n    this.order.push(entry);\n    injector.ptr = entry.end;\n    this.index++;\n}\nfunction mountEntry(block, value, key, index) {\n    const { host, injector, body: mount } = block;\n    const scope = prepareScope(obj(block.scope), index, key, value);\n    setScope(host, scope);\n    const entry = injectBlock(injector, {\n        host,\n        injector,\n        scope,\n        mount,\n        update: undefined,\n        next: null\n    });\n    injector.ptr = entry.start;\n    entry.update = mount && mount(host, injector, scope);\n    return entry;\n}\nfunction updateEntry(entry, value, key, index) {\n    if (entry.update) {\n        const { host } = entry;\n        const scope = prepareScope(entry.scope, index, key, value);\n        setScope(host, scope);\n        if (entry.update(host, scope)) {\n            return 1;\n        }\n    }\n    return 0;\n}\nfunction reorder(block) {\n    const { injector, order } = block;\n    let actualPrev;\n    let actualNext;\n    let expectedPrev;\n    let expectedNext;\n    const { start, end } = block;\n    for (let i = 0, maxIx = order.length - 1, item; i <= maxIx; i++) {\n        item = order[i];\n        expectedPrev = i > 0 ? order[i - 1] : null;\n        expectedNext = i < maxIx ? order[i + 1] : null;\n        actualPrev = getItem(item.start.prev, start);\n        actualNext = getItem(item.end.next, end);\n        if (expectedPrev !== actualPrev || expectedNext !== actualNext) {\n            // Blocks must be reordered\n            move(injector, item, expectedPrev ? expectedPrev.end : block.start);\n        }\n    }\n}\nfunction getLookup(lookup, key) {\n    const item = lookup[key];\n    if (item && (lookup[key] = item.next)) {\n        item.next = null;\n    }\n    return item;\n}\nfunction putLookup(lookup, key, value) {\n    value.next = lookup[key];\n    lookup[key] = value;\n}\nfunction disposeLookup(lookup) {\n    let updated = 0;\n    for (const p in lookup) {\n        let item = lookup[p];\n        while (item) {\n            updated = 1;\n            disposeBlock(item);\n            item = item.next;\n        }\n    }\n    return updated;\n}\n\n/**\n * Adds given element as a named ref\n */\nfunction setRef(host, key, elem) {\n    elem.setAttribute(getRefAttr(key, host), '');\n    host.refs[key] = elem;\n}\n/**\n * Removes ref for given key\n */\nfunction removeRef(host, key) {\n    // NB: Do not remove ref attribute in order to keep CSS styles for animated\n    // ref’ed element (`animate:out`). In case if its introduces unexpected side\n    // effects, update compiler to properly unmount refs but keep HTML attribute\n    // for animated elements\n    // const elem = host.refs[key];\n    // if (elem) {\n    // \telem.removeAttribute(getRefAttr(key, host));\n    // }\n    host.refs[key] = null;\n}\nfunction setPendingRef(pending, key, elem) {\n    if (key && elem) {\n        pending[key] = elem;\n    }\n}\nfunction finalizePendingRefs(host, pending) {\n    for (const key in pending) {\n        const prev = host.refs[key];\n        const next = pending[key];\n        if (prev !== next) {\n            prev && removeRef(host, key);\n            next && setRef(host, key, next);\n        }\n        pending[key] = null;\n    }\n}\n/**\n * Returns attribute name to identify element in CSS\n */\nfunction getRefAttr(name, host) {\n    const cssScope = host.componentModel.definition.cssScope;\n    return 'ref-' + name + (cssScope ? '-' + cssScope : '');\n}\n\n/**\n * Renders code, returned from `get` function, as HTML\n */\nfunction mountInnerHTML(host, injector, get, slotName) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        code: null,\n        slotName\n    });\n    updateInnerHTML(block);\n    return block;\n}\n/**\n * Updates inner HTML of block, defined in `ctx`\n * @returns Returns `1` if inner HTML was updated, `0` otherwise\n */\nfunction updateInnerHTML(block) {\n    const { host, injector, scope } = block;\n    const code = block.get(host, scope);\n    if (code !== block.code) {\n        emptyBlockContent(block);\n        if (isDefined(block.code = code)) {\n            injector.ptr = block.start;\n            renderHTML(host, injector, code, block.slotName);\n        }\n        injector.ptr = block.end;\n        return 1;\n    }\n    return 0;\n}\nfunction unmountInnerHTML(block) {\n    disposeBlock(block);\n}\nfunction clearInnerHTML(block) {\n    disposeBlock(block, true);\n}\nfunction renderHTML(host, injector, code, slotName) {\n    const { cssScope } = host.componentModel.definition;\n    if (isNode(code)) {\n        // Insert as DOM element\n        cssScope && scopeDOM(code, cssScope);\n        if (code.nodeType === code.DOCUMENT_FRAGMENT_NODE) {\n            // Insert document fragment contents separately to properly maintain\n            // list of inserted elements\n            while (code.firstChild) {\n                insert(injector, code.firstChild, slotName);\n            }\n        }\n        else {\n            insert(injector, code, slotName);\n        }\n    }\n    else {\n        // Render as HTML\n        const div = document.createElement('div');\n        div.innerHTML = code;\n        cssScope && scopeDOM(div, cssScope);\n        while (div.firstChild) {\n            insert(injector, div.firstChild, slotName);\n        }\n    }\n}\n/**\n * Scopes CSS of all elements in given node\n */\nfunction scopeDOM(node, cssScope) {\n    node = node.firstChild;\n    while (node) {\n        if (node.nodeType === node.ELEMENT_NODE) {\n            isolateElement(node, cssScope);\n            scopeDOM(node, cssScope);\n        }\n        node = node.nextSibling;\n    }\n}\nfunction isNode(obj) {\n    return obj && obj.nodeType;\n}\n\nfunction getPartial(host, name, componentPartials) {\n    return host.props['partial:' + name] || componentPartials[name];\n}\n/**\n * Mounts given partial into injector context\n */\nfunction mountPartial(host, injector, partial, args) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        mount: void 0,\n        update: void 0,\n        partial: null\n    });\n    updatePartial(block, partial, args);\n    return block;\n}\n/**\n * Updates mounted partial\n * @returns Returns `1` if partial was updated, `0` otherwise\n */\nfunction updatePartial(block, partial, args) {\n    const host = partial.host || block.host;\n    const { injector } = block;\n    const prevHost = block.host;\n    const prevScope = getScope(host);\n    let updated = 0;\n    block.host = host;\n    if (block.partial !== partial) {\n        // Unmount previously rendered partial\n        block.partial && emptyBlockContent(block);\n        // Mount new partial\n        const scope = block.scope = assign(obj(prevScope), partial.defaults, args);\n        setScope(host, scope);\n        injector.ptr = block.start;\n        block.mount = partial && partial.body;\n        block.update = block.mount && block.mount(host, injector, scope);\n        block.partial = partial;\n        setScope(host, prevScope);\n        updated = 1;\n    }\n    else if (block.update) {\n        // Update rendered partial\n        const scope = setScope(host, assign(block.scope, args));\n        if (block.update(host, scope)) {\n            updated = 1;\n        }\n        setScope(host, prevScope);\n    }\n    block.host = prevHost;\n    injector.ptr = block.end;\n    return updated;\n}\nfunction unmountPartial(block) {\n    disposeBlock(block);\n}\nfunction clearPartial(block) {\n    disposeBlock(block, true);\n}\n\nconst prefix = '$';\nclass Store {\n    constructor(data) {\n        this.sync = false;\n        this.listeners = [];\n        this.data = assign({}, data || {});\n    }\n    /**\n     * Returns current store data\n     */\n    get() {\n        return this.data;\n    }\n    /**\n     * Updates data in store\n     */\n    set(data) {\n        const updated = changed(data, this.data, prefix);\n        const render = this.sync ? renderComponent : scheduleRender;\n        if (updated) {\n            const next = this.data = assign(this.data, data);\n            // Notify listeners.\n            // Run in reverse order for listener safety (in case if handler decides\n            // to unsubscribe during notification)\n            for (let i = this.listeners.length - 1, item; i >= 0; i--) {\n                item = this.listeners[i];\n                if (!item.keys || !item.keys.length || hasChange(item.keys, updated)) {\n                    if ('component' in item) {\n                        render(item.component, updated);\n                    }\n                    else if ('handler' in item) {\n                        item.handler(next, updated);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Subscribes to changes in given store\n     * @param handler Function to invoke when store changes\n     * @param keys Run handler only if given top-level keys are changed\n     * @returns Object that should be used to unsubscribe from updates\n     */\n    subscribe(handler, keys) {\n        const obj = {\n            handler,\n            keys: scopeKeys(keys, prefix)\n        };\n        this.listeners.push(obj);\n        return obj;\n    }\n    /**\n     * Unsubscribes from further updates\n     */\n    unsubscribe(obj) {\n        const ix = this.listeners.indexOf(obj);\n        if (ix !== -1) {\n            this.listeners.splice(ix, 1);\n        }\n    }\n    /**\n     * Watches for updates of given `keys` in store and runs `component` render on change\n     */\n    watch(component, keys) {\n        this.listeners.push({\n            component,\n            keys: scopeKeys(keys, prefix)\n        });\n    }\n    /**\n     * Stops watching for store updates for given component\n     * @param {Component} component\n     */\n    unwatch(component) {\n        for (let i = 0; i < this.listeners.length; i++) {\n            if (this.listeners[i].component === component) {\n                this.listeners.splice(i, 1);\n            }\n        }\n    }\n}\n/**\n * Check if any of `keys` was changed in `next` object since `prev` state\n * @param {string[]} keys\n * @param {Object} updated\n * @return {boolean}\n */\nfunction hasChange(keys, updated) {\n    for (let i = 0; i < keys.length; i++) {\n        if (keys[i] in updated) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Adds given prefix to keys\n */\nfunction scopeKeys(keys, pfx) {\n    return keys && pfx ? keys.map(key => pfx + key) : keys;\n}\n\nconst pool = [];\nconst defaultTween = {\n    duration: 500,\n    delay: 0,\n    easing(t, b, c, d) {\n        return c * t / d + b;\n    }\n};\n// If `true` then no animations will be invoked\nlet blocked = false;\n/**\n * Starts animation on given element\n */\nfunction animate(elem, animation, callback) {\n    if (!blocked && animation) {\n        if (typeof animation === 'function') {\n            tweenAnimate(elem, animation, callback);\n        }\n        else {\n            cssAnimate(elem, animation, callback);\n        }\n    }\n    else if (callback) {\n        // Stop previous animation, if any\n        stopAnimation(elem, true);\n        callback();\n    }\n}\n/**\n * Starts CSS animation on given element\n */\nfunction cssAnimate(elem, animation, callback) {\n    // Stop previous animation, if any\n    stopAnimation(elem, true);\n    let timer;\n    const prevAnimation = elem.style.animation;\n    const evtPayload = {\n        animation,\n        direction: callback ? 'out' : 'in'\n    };\n    elem[animatingKey] = (cancel) => {\n        clearTimeout(timer);\n        elem.removeEventListener('animationend', handler);\n        elem.removeEventListener('animationcancel', handler);\n        elem.style.animation = prevAnimation;\n        notifyAnimation(elem, 'end', evtPayload);\n        !cancel && finalizeAnimation(callback);\n    };\n    const handler = (evt) => evt.target === elem && stopAnimation(elem);\n    elem.addEventListener('animationend', handler);\n    elem.addEventListener('animationcancel', handler);\n    elem.style.animation = animation;\n    // In case if callback is provided, we have to ensure that animation is actually applied.\n    // In some testing environments, animations could be disabled via\n    // `* { animation: none !important; }`. In this case, we should complete animation ASAP.\n    if (callback) {\n        nextTick(() => {\n            const style = window.getComputedStyle(elem, null);\n            if (!style.animationName || style.animationName === 'none') {\n                stopAnimation(elem);\n            }\n            else {\n                // Handle edge case: animation runs but during animation parent\n                // element is unmounted. In this case `animationend` callback won’t\n                // fire, causing memory leak.\n                // Create timer which will forcibly dispose animation after animation\n                // duration\n                const duration = parseDuration(style.animationDelay) + parseDuration(style.animationDuration);\n                if (duration) {\n                    timer = window.setTimeout(() => stopAnimation(elem), duration);\n                }\n            }\n        });\n    }\n    notifyAnimation(elem, 'start', evtPayload);\n}\n/**\n * Starts JS animation on given element\n */\nfunction tweenAnimate(elem, animation, callback) {\n    // Stop previous animation, if any\n    const prevAnim = findTween(elem);\n    stopAnimation(elem, true);\n    let options = animation(elem);\n    if (options) {\n        options = assign({}, defaultTween, options);\n        if (typeof options.easing !== 'function') {\n            throw new Error('Easing must be a function');\n        }\n        const now = performance.now();\n        const offset = prevAnim\n            ? 1 - (now - prevAnim.start) / (prevAnim.end - prevAnim.start)\n            : 0;\n        const start = now + options.delay - (offset * options.duration);\n        const anim = {\n            elem,\n            options,\n            start,\n            end: start + options.duration,\n            started: false\n        };\n        const evtPayload = {\n            animation,\n            tween: options,\n            direction: callback ? 'out' : 'in'\n        };\n        pool.push(anim);\n        elem[animatingKey] = (cancel) => {\n            pool.splice(pool.indexOf(anim), 1);\n            options.complete && options.complete(elem, options);\n            notifyAnimation(elem, 'end', evtPayload);\n            !cancel && finalizeAnimation(callback);\n        };\n        if (pool.length === 1) {\n            tweenLoop(now);\n        }\n        notifyAnimation(elem, 'start', evtPayload);\n    }\n    else if (callback) {\n        callback();\n    }\n}\n/**\n * Creates animation CSS value with scoped animation name\n */\nfunction createAnimation(animation, cssScope) {\n    if (animation == null) {\n        return '';\n    }\n    const parts = String(animation).split(' ');\n    const name = parts[0].trim();\n    const globalPrefix = 'global:';\n    if (name.indexOf(globalPrefix) === 0) {\n        // Do not scope animation name, use globally defined animation name\n        parts[0] = name.slice(globalPrefix.length);\n    }\n    else if (cssScope) {\n        parts[0] = concat(name, cssScope);\n    }\n    return parts.join(' ').trim();\n}\n/**\n * Composes two tween options objects into single one: instead of simple `assign`,\n * callbacks from both tweens will be composed into a single call\n */\nfunction composeTween(tween1, tween2) {\n    const next = assign({}, tween1, tween2);\n    const callbacks = ['start', 'step', 'complete'];\n    for (let i = 0; i < callbacks.length; i++) {\n        const cbName = callbacks[i];\n        const cb1 = tween1 && tween1[cbName];\n        const cb2 = tween2 && tween2[cbName];\n        if (cb1 && cb2) {\n            next[cbName] = (elem, p1, p2) => {\n                cb1(elem, p1, p2);\n                cb2(elem, p1, p2);\n            };\n        }\n    }\n    return next;\n}\n/**\n * Finalizes current animation: invokes given callback and blocks all nested\n * animations\n */\nfunction finalizeAnimation(callback) {\n    if (callback) {\n        blocked = true;\n        safeCall(callback);\n        blocked = false;\n    }\n}\nfunction tweenLoop(now) {\n    for (let i = pool.length - 1, anim; i >= 0; i--) {\n        anim = pool[i];\n        const { elem, options } = anim;\n        if (now >= anim.start) {\n            if (!anim.started) {\n                anim.started = true;\n                options.start && options.start(elem, options);\n            }\n            const finished = now >= anim.end;\n            const pos = finished ? 1 : options.easing(now - anim.start, 0, 1, options.duration);\n            options.step && options.step(elem, pos, options);\n            if (finished) {\n                stopAnimation(elem);\n            }\n        }\n    }\n    if (pool.length) {\n        requestAnimationFrame(tweenLoop);\n    }\n}\nfunction stopAnimation(elem, cancel) {\n    const callback = elem && elem[animatingKey];\n    if (callback) {\n        elem[animatingKey] = null;\n        callback(cancel);\n    }\n}\n/**\n * Finds existing tween animation for given element, if any\n */\nfunction findTween(elem) {\n    for (let i = 0; i < pool.length; i++) {\n        if (pool[i].elem === elem) {\n            return pool[i];\n        }\n    }\n    return null;\n}\n/**\n * Concatenates two strings with optional separator\n */\nfunction concat(name, suffix) {\n    const sep = suffix[0] === '_' || suffix[0] === '-' ? '' : '-';\n    return name + sep + suffix;\n}\nfunction nextTick(fn) {\n    if (typeof Promise !== 'undefined') {\n        Promise.resolve().then(fn);\n    }\n    else {\n        requestAnimationFrame(fn);\n    }\n}\nfunction notifyAnimation(elem, stage, detail) {\n    try {\n        elem.dispatchEvent(new CustomEvent(`animate-${stage}`, {\n            bubbles: false,\n            cancelable: false,\n            detail\n        }));\n    }\n    catch (err) {\n        // pass\n    }\n}\nfunction parseDuration(value) {\n    if (!value) {\n        return 0;\n    }\n    const ms = value.indexOf('ms') !== -1 ? 1 : 1000;\n    return parseFloat(value) * ms;\n}\n\n/**\n * Creates Endorphin component and mounts it into given `options.target` container\n */\nfunction endorphin(name, definition, options = {}) {\n    const component = createComponent(name, definition, options.target);\n    if (options.store) {\n        component.store = options.store;\n    }\n    if (options.target && !options.detached) {\n        options.target.appendChild(component);\n    }\n    mountComponent(component, options.props);\n    return component;\n}\n/**\n * Safe property getter\n * @param {*} ctx\n * @param {*} ...args\n * @returns {*}\n */\nfunction get(ctx) {\n    const hasMap = typeof Map !== 'undefined';\n    for (let i = 1, il = arguments.length, arg; ctx != null && i < il; i++) {\n        arg = arguments[i];\n        if (hasMap && ctx instanceof Map) {\n            ctx = ctx.get(arg);\n        }\n        else {\n            ctx = ctx[arg];\n        }\n    }\n    return ctx;\n}\n/**\n * Invokes `methodName` of `ctx` object with given args\n */\nfunction call(ctx, methodName, args) {\n    const method = ctx != null && ctx[methodName];\n    if (typeof method === 'function') {\n        return args ? method.apply(ctx, args) : method.call(ctx);\n    }\n}\n/**\n * Filter items from given collection that matches `fn` criteria and returns\n * matched items\n */\nfunction filter(collection, fn) {\n    const result = [];\n    if (collection && collection.forEach) {\n        collection.forEach((value, key) => {\n            if (fn(value, key)) {\n                result.push(value);\n            }\n        });\n    }\n    return result;\n}\n/**\n * Finds first item in given `collection` that matches truth test of `fn`\n */\nfunction find(collection, fn) {\n    if (Array.isArray(collection)) {\n        // Fast path: find item in array\n        for (let i = 0, item; i < collection.length; i++) {\n            item = collection[i];\n            if (fn(item, i)) {\n                return item;\n            }\n        }\n    }\n    else if (collection && collection.forEach) {\n        // Iterate over collection\n        let found = false;\n        let result = null;\n        collection.forEach((value, key) => {\n            if (!found && fn(value, key)) {\n                found = true;\n                result = value;\n            }\n        });\n        return result;\n    }\n}\n\nexport default endorphin;\nexport { Store, addEvent, addPendingClass, addPendingClassIf, animate, appendChild, assign, call, classNames, clearBlock, clearInnerHTML, clearIterator, clearKeyIterator, clearPartial, composeTween, createAnimation, createComponent, createComponentFromElement, createInjector, createScope, createSlot, cssAnimate, detachPendingEvents, disposeBlock, domInsert, domRemove, elem, elemNS, elemNSWithText, elemWithText, emptyBlockContent, enterScope, exitScope, filter, finalizeAttributes, finalizePendingEvents, finalizePendingRefs, find, get, getPartial, getProp, getScope, getSlotContext, getState, getVar, injectBlock, inputValue, insert, isolateElement, mountBlock, mountComponent, mountInnerHTML, mountIterator, mountKeyIterator, mountPartial, mountSlot, move, notifySlotUpdate, obj, pendingEvents, prepareScope, propsSet, removeEvent, removeRef, renderComponent, safeEventListener, scheduleRender, setAttribute, setAttributeExpression, setAttributeExpressionNS, setAttributeNS, setClass, setPendingAttributeNS, setPendingEvent, setPendingRef, setRef, setScope, setVar, stopAnimation, subscribeStore, text, tweenAnimate, unmountBlock, unmountComponent, unmountInnerHTML, unmountIterator, unmountKeyIterator, unmountPartial, unmountSlot, updateAttribute, updateAttributeNS, updateBlock, updateClass, updateComponent, updateDefaultSlot, updateIncomingSlot, updateInnerHTML, updateIterator, updateKeyIterator, updatePartial, updatePendingAttribute, updatePendingAttributeNS, updateProperty, updateText };\n//# sourceMappingURL=runtime.es.js.map\n",null,null,null,"<link rel=\"stylesheet\" href=\"./rod-logo.scss\" />\n\n<template>\n    <e:var route={ $routes[item => item.home] }/>\n\n    <a title={ @route.title } href={ @route.path } on:click:prevent={ $.router.navigateTo(@route) }>\n        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"126\" height=\"144\" viewBox=\"0 0 126 144\" fill=\"none\">\n            <path d=\"M59.5 113.7C59.3 94.1 56.5 72.8 44.6 60.9 32.6 49 13.6 50.6 5.7 67.8 -5.9 93.4 37.5 100.5 31.4 72.8\" style=\"stroke-linejoin:round;stroke-width:5;stroke:#22C8ED\"/>\n            <path d=\"M80.9 64C76.5 73.3 89.2 95.5 107.2 88.5 125.3 81.5 123.9 57.9 114.5 49.7 105.2 41.6 93.1 36.8 78.2 50.6 78.2 50.6 63.6 64 65.9 107.9\" style=\"stroke-linejoin:round;stroke-width:5;stroke:#33AAEB\"/>\n            <path d=\"M61.2 69.8C52.3 59.2 44.9 45.2 45.7 31.7 46.5 18.1 53.2 7.6 70.6 10.4 88 13.1 89.3 42.9 70.3 43.5\" style=\"stroke-linejoin:round;stroke-width:5;stroke:#447DEB\"/>\n            <path d=\"M61.1 142.3C53 124.9 70.5 101.9 74.7 110.9 78.9 119.9 61.1 142.3 61.1 142.3Z\" style=\"fill:#12D047;\"/>\n            <path d=\"M61.3 142C93 143.4 117.9 111.2 101.4 110.4 85 109.6 61.3 142 61.3 142Z\" style=\"fill:#12D047;\"/>\n            <path d=\"M64 142C33.2 143.4 9.1 111.2 25.1 110.4 41 109.6 64 142 64 142Z\" style=\"fill:#12D047;\"/>\n            <path d=\"M106.9 35.5C116.9 32.6 129.7 40.3 123.3 43.2 116.9 46 114.9 40.1 106.9 35.5Z\" style=\"fill:#447DEB;\"/>\n            <path d=\"M31.3 24C28.6 13.9 15.5 6.8 16.3 13.8 17.1 20.8 23.2 19.4 31.3 24Z\" style=\"fill:#447DEB;\"/>\n            <path d=\"M20.6 38C11.7 32.6-2.6 36.8 2.8 41.2 8.3 45.6 11.7 40.4 20.6 38Z\" style=\"fill:#447DEB;\"/>\n            <path d=\"M97.4 23.7C101.1 13.9 115 8.4 113.4 15.3 111.8 22.1 105.9 20.1 97.4 23.7Z\" style=\"fill:#447DEB;\"/>\n        </svg>\n    </a>\n</template>\n","<link rel=\"stylesheet\" href=\"./rod-title.scss\" />\n\n<template>\n    <h1>Родник</h1>\n    <h2>Общественная Экологическая Организация</h2>\n</template>\n","<link rel=\"stylesheet\" href=\"./rod-menu.scss\" />\n\n<template>\n    <nav class=\"menu\">\n        <ul>\n            <e:for-each select={ $routes[[item => !item.home]] } key={ @value.path }>\n                <li class:selected={ @value == $currentRoute }>\n                    <a href={ @value.path }\n                       on:click:prevent={ $.router.navigateTo(@value) }>\n                       { @value.title }\n                    </a>\n                </li>\n            </e:for-each>\n        </ul>\n    </nav>\n</template>\n","<link rel=\"import\" href=\"../rod-logo/rod-logo.html\" />\n<link rel=\"import\" href=\"../rod-title/rod-title.html\" />\n<link rel=\"import\" href=\"../rod-menu/rod-menu.html\" />\n<link rel=\"import\" href=\"../rod-social-links/rod-social-links.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-page.scss\" />\n\n<template>\n    <header>\n        <rod-logo />\n        <rod-title />\n        <rod-menu />\n        <rod-social-links />\n    </header>\n    <div class=\"divider\"></div>\n    <main>\n        <slot />\n    </main>\n    <footer />\n</template>\n","<link rel=\"stylesheet\" href=\"./rod-news-item.scss\" />\n<script src=\"./rod-news-item.ts\"></script>\n\n<template>\n    <div class=\"topic\" on:click={ $.router.navigateTo(#route) }>\n\n        <div class=\"preview\" style=\"background-image:url({ topic.image })\" />\n\n        <div class=\"content\">\n\n            <p class=\"date\">{{ #formattedDate }}</p>\n            \n            <p class=\"text\">{{ topic.title }}</p>\n\n            <p class=\"direct-link\">\n                <a href={ #route } on:click:prevent:stop={ $.router.navigateTo(#route) }>\n                    Подробнее\n                </a>\n            </p>\n\n        </div>\n\n    </div>\n</template>\n",null,"<link rel=\"import\" href=\"../rod-news-item/rod-news-item.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-news-list.scss\" />\n\n<template>\n    <h2>Новости</h2>\n    <div class=\"news-list\">\n        <e:for-each select={ $news } key={ @value.name }>\n            <rod-news-item topic={ @value } />\n        </e:for-each>\n    </div>\n</template>\n","<link rel=\"import\" href=\"../rod-page/rod-page.html\" />\n<link rel=\"import\" href=\"../rod-news-list/rod-news-list.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-page-main.scss\" />\n\n<template>\n    <rod-page>\n        <rod-news-list />\n    </rod-page>\n</template>\n","<link rel=\"stylesheet\" href=\"./rod-documents.scss\" />\n\n<template>\n    <h2>Регистрационные документы</h2>\n    <ul>\n        <li>\n            <a href=\"https://cloud.mail.ru/public/2isj/atSz1DRVw/\" target=\"_blank\">Устав ОЭО \"Родник\" и форма заявления о вступлении</a>\n        </li>\n    </ul>\n\n    <h2>Наша деятельность</h2>\n    <ul>\n        <li>\n            <a href=\"https://cloud.mail.ru/public/aeF8/4oY2adJsb/\" target=\"_blank\">Письма и ответы</a>\n        </li>\n        <li>\n            <a href=\"https://cloud.mail.ru/public/4732/4QnMzF4Dp/\" target=\"_blank\">Обращение от 12.12.2020</a>\n        </li>\n    </ul>\n    \n    <h2>Пресса о нас</h2>\n    <ul>\n        <li>\n            <a href=\"https://cloud.mail.ru/public/mzKx/NzT9oowzQ/\" target=\"_blank\">Публикации в прессе</a>\n        </li>\n    </ul>\n</template>\n","<link rel=\"import\" href=\"../rod-page/rod-page.html\" />\n<link rel=\"import\" href=\"../rod-documents/rod-documents.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-page-about.scss\" />\n\n<template>\n    <rod-page>\n        <rod-documents/>\n    </rod-page>\n</template>\n","<link rel=\"import\" href=\"../rod-page/rod-page.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-page-events.scss\" />\n\n<template>\n    <rod-page>\n        <h1>Мероприятия</h1>\n    </rod-page>\n</template>\n","<link rel=\"import\" href=\"../rod-page/rod-page.html\" />\n<link rel=\"import\" href=\"../rod-news-list/rod-news-list.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-page-news.scss\" />\n\n<template>\n    <rod-page>\n        <rod-news-list />\n    </rod-page>\n</template>\n","<link rel=\"import\" href=\"../rod-page/rod-page.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-page-support.scss\" />\n\n<template>\n    <rod-page>\n        <h2>Поддержать</h2>\n    </rod-page>\n</template>\n","<link rel=\"import\" href=\"../rod-page/rod-page.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-page-contacts.scss\" />\n\n<template>\n    <rod-page>\n        <h2>Контакты</h2>\n        <p>\n            По всем вопросам пишите на наш <a href=\"mailto:39rodnik@mail.ru\">email</a>.\n        </p>\n    </rod-page>\n</template>\n",null,"<link rel=\"import\" href=\"../rod-page/rod-page.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-page-topic.scss\" />\n<script src=\"./rod-page-topic.ts\"></script>\n\n<template>\n    <rod-page>\n        <div class=\"illustration\" style=\"background-image:url({ topic.image })\" />\n        <p class=\"date\">{{ #formattedDate }}</p>\n        <div class=\"content\">{{ topic.text }}</div>\n    </rod-page>\n</template>\n",null,"<link rel=\"import\" href=\"../rod-page-main/rod-page-main.html\" />\n<link rel=\"import\" href=\"../rod-page-about/rod-page-about.html\" />\n<link rel=\"import\" href=\"../rod-page-events/rod-page-events.html\" />\n<link rel=\"import\" href=\"../rod-page-news/rod-page-news.html\" />\n<link rel=\"import\" href=\"../rod-page-support/rod-page-support.html\" />\n<link rel=\"import\" href=\"../rod-page-contacts/rod-page-contacts.html\" />\n<link rel=\"import\" href=\"../rod-page-topic/rod-page-topic.html\" />\n\n<link rel=\"stylesheet\" href=\"./rod-app.scss\" />\n\n<template>\n    <e:switch>\n        <e:case test={ $currentRoute.topic }>\n            <rod-page-topic topic={ $currentRoute.topic } />\n        </e:case>\n        <e:case test={ $currentRoute.path==='/' }>\n            <rod-page-main />\n        </e:case>\n        <e:case test={ $currentRoute.path==='/about' }>\n            <rod-page-about />\n        </e:case>\n        <e:case test={ $currentRoute.path==='/events' }>\n            <rod-page-events />\n        </e:case>\n        <e:case test={ $currentRoute.path==='/news' }>\n            <rod-page-news />\n        </e:case>\n        <e:case test={ $currentRoute.path==='/support' }>\n            <rod-page-support />\n        </e:case>\n        <e:case test={ $currentRoute.path==='/contacts' }>\n            <rod-page-contacts />\n        </e:case>\n    </e:switch>\n</template>\n"],"names":["appendChild","element","node","elem","tagName","cssScope","const","el","document","createElement","isolateElement","elemNS","ns","createElementNS","elemWithText","value","textNode","text","$value","createTextNode","setAttribute","domInsert","parent","anchor","insertBefore","obj","proto","Object","create","isDefined","assign","target","i","source","arguments","length","p","hasOwnProperty","getObjectDescriptors","descriptors","props","getOwnPropertyNames","prop","descriptor","getOwnPropertyDescriptor","captureError","host","fn","arg1","arg2","error","runtimeError","console","CustomEvent","dispatchEvent","bubbles","cancelable","detail","addEvent","type","listener","scope","binding","addEventListener","registerBinding","handleEvent","removeEvent","removeEventListener","event","this","safeEventListener","handler","call","propsSet","initial","base","componentModel","defaultProps","name","updateAttribute","prev","primitive","representedValue","removeAttribute","setClass","className","setAttributeExpression","Array","isArray","uniqueClassFilter","cl","index","arr","indexOf","createListItem","next","listPrependValue","list","item","head","listInsertValueAfter","ref","listDetachFragment","start","end","createInjector","parentNode","ptr","slots","insert","injector","slotName","getSlotContext","getAnchorNode","injectBlock","block","isDefault","defaultContent","createSlotContext","emptyBlockContent","detached","unmount","mount","dispose","let","isElement","removeChild","disposeBlock","move","listMoveFragmentAfter","listMoveFragmentFirst","runHook","component","plugins","hook","setScope","vars","getScope","notifySlotUpdate","ctx","renderDefaultContent","content","update","setSlotted","isEmpty","childNodes","slotted","renderQueue","attributeLookup","createComponent","definition","root","events","extend","state","collectPlugins","dest","push","dfn","methods","getDescriptors","createEventsMap","attachEventHandlers","prepare","refs","componentView","setProps","mounted","changes","setPropsInternal","renderNext","setState","hasChanges","preparing","scheduleRender","addPropsState","defineProperties","store","input","queued","partialDeps","createComponentFromElement","mountComponent","arg","default","updateComponent","partialDepsUpdated","unmountComponent","eventMap","listeners","detachStaticEvents","unwatch","subscribeStore","keys","Error","watch","renderComponent","requestAnimationFrame","drainQueue","kebabCase","ch","toLowerCase","nextProps","current","str","String","split","filter","join","test","normalizeAttribute","evt","handlers","names","pending","attr","replace","updateBlock","updated","get","prepareScope","key","mountKeyIterator","keyExpr","body","parentScope","used","rendered","needReorder","order","updateKeyIterator","collection","forEach","prevScope","keyIterator","lookup","disposeLookup","actualPrev","actualNext","expectedPrev","expectedNext","maxIx","getItem","reorder","unmountKeyIterator","listItem","bound","id","entry","getLookup","updateEntry","undefined","mountEntry","putLookup","mountInnerHTML","code","updateInnerHTML","nodeType","isNode","scopeDOM","DOCUMENT_FRAGMENT_NODE","firstChild","div","innerHTML","renderHTML","unmountInnerHTML","ELEMENT_NODE","nextSibling","Store","data","sync","hasChange","scopeKeys","pfx","map","hasMap","Map","il","methodName","args","method","apply","set","prefix","result","dirty","changed","render","subscribe","unsubscribe","ix","splice","DYNAMIC_ROUTE_RE","RodRouter","topics","homeRoute","find","r","home","_appTitle","title","window","onpopstate","navigateTo","initPath","path","prototypeAccessors","a","_a","recover","route","_resolveRoute","_activateRoute","isPushStateRequired","_getRouteTitle","url","_getRouteUrl","currentRoute","history","pushState","href","pn","pathname","routes","match","baseRoute","dynamic","includes","topic","dynamicPath","RodTopicService","news","t","RodStore","initData","super","router","found","nodeValue","createSlot","formattedDate","date","Date","getDate","getMonth","getFullYear","formatDate","options","endorphin","storage","sessionStorage","removeItem"],"mappings":"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"}