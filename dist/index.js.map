{"version":3,"file":"index.js","sources":["../node_modules/endorphin/runtime/runtime.es.js","../src/components/rod-app/rod-app.ts","../src/components/rod-app/rod-app.html","../src/index.ts"],"sourcesContent":["/**\n * Shorthand for `elem.appendChild()` for better minification\n */\nfunction appendChild(element, node) {\n    return element.appendChild(node);\n}\n/**\n * Creates element with given tag name\n * @param cssScope Scope for CSS isolation\n */\nfunction elem(tagName, cssScope) {\n    const el = document.createElement(tagName);\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Creates element with given tag name under `ns` namespace\n * @param cssScope Scope for CSS isolation\n */\nfunction elemNS(tagName, ns, cssScope) {\n    const el = document.createElementNS(ns, tagName);\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Creates element with given tag name and text\n * @param cssScope Scope for CSS isolation\n */\nfunction elemWithText(tagName, value, cssScope) {\n    const el = elem(tagName, cssScope);\n    el.appendChild(textNode(value));\n    return el;\n}\n/**\n * Creates element with given tag name under `ns` namespace and text\n * @param cssScope Scope for CSS isolation\n */\nfunction elemNSWithText(tagName, ns, value, cssScope) {\n    const el = elemNS(tagName, ns, cssScope);\n    el.appendChild(textNode(value));\n    return el;\n}\n/**\n * Creates text node with given value\n */\nfunction text(value) {\n    const node = textNode(value);\n    node.$value = value;\n    return node;\n}\n/**\n * Creates text node with given value\n */\nfunction textNode(value) {\n    return document.createTextNode(value != null ? value : '');\n}\n/**\n * Updates given text node value, if required\n * @returns Returns `1` if text was updated, `0` otherwise\n */\nfunction updateText(node, value) {\n    if (value !== node.$value) {\n        // node.nodeValue = textValue(value);\n        node.nodeValue = value != null ? value : '';\n        node.$value = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Isolates given element with CSS scope\n */\nfunction isolateElement(el, cssScope) {\n    el.setAttribute(cssScope, '');\n    return el;\n}\n/**\n * @returns Inserted item\n */\nfunction domInsert(node, parent, anchor) {\n    return anchor\n        ? parent.insertBefore(node, anchor)\n        : parent.appendChild(node);\n}\n/**\n * Removes given DOM node from its tree\n * @param {Node} node\n */\nfunction domRemove(node) {\n    const { parentNode } = node;\n    parentNode && parentNode.removeChild(node);\n}\n/**\n * Returns textual representation of given `value` object\n */\n// function textValue(value: any): string {\n// \treturn value != null ? value : '';\n// }\n\nconst animatingKey = '$$animating';\n/**\n * Creates fast object\n */\nfunction obj(proto = null) {\n    return Object.create(proto);\n}\n/**\n * Check if given value id defined, e.g. not `null`, `undefined` or `NaN`\n */\nfunction isDefined(value) {\n    return value != null && value === value;\n}\n/**\n * Returns properties from `next` which were changed since `prev` state.\n * Returns `null` if there are no changes\n */\nfunction changed(next, prev, prefix = '') {\n    const result = obj();\n    let dirty = false;\n    // Check if data was actually changed\n    for (const p in next) {\n        if (prev[p] !== next[p]) {\n            dirty = true;\n            result[prefix ? prefix + p : p] = {\n                prev: prev[p],\n                current: next[p]\n            };\n        }\n    }\n    return dirty ? result : null;\n}\n// tslint:disable-next-line:only-arrow-functions\nconst assign = Object.assign || function (target) {\n    for (let i = 1, source; i < arguments.length; i++) {\n        source = arguments[i];\n        for (const p in source) {\n            if (source.hasOwnProperty(p)) {\n                target[p] = source[p];\n            }\n        }\n    }\n    return target;\n};\n/**\n * Returns property descriptors from given object\n */\n// tslint:disable-next-line:only-arrow-functions\nconst getObjectDescriptors = Object['getOwnPropertyDescriptors'] || function (source) {\n    const descriptors = obj();\n    const props = Object.getOwnPropertyNames(source);\n    for (let i = 0, prop, descriptor; i < props.length; i++) {\n        prop = props[i];\n        descriptor = Object.getOwnPropertyDescriptor(source, prop);\n        if (descriptor != null) {\n            descriptors[prop] = descriptor;\n        }\n    }\n    return descriptors;\n};\nfunction safeCall(fn, arg1, arg2) {\n    try {\n        return fn && fn(arg1, arg2);\n    }\n    catch (err) {\n        // tslint:disable-next-line:no-console\n        console.error(err);\n    }\n}\nfunction captureError(host, fn, arg1, arg2) {\n    try {\n        return fn && fn(arg1, arg2);\n    }\n    catch (error) {\n        runtimeError(host, error);\n        // tslint:disable-next-line:no-console\n        console.error(error);\n    }\n}\nfunction runtimeError(host, error) {\n    if (typeof CustomEvent !== 'undefined') {\n        host.dispatchEvent(new CustomEvent('runtime-error', {\n            bubbles: true,\n            cancelable: true,\n            detail: { error, host }\n        }));\n    }\n    else {\n        throw error;\n    }\n}\n\n/**\n * Registers given event listener on `target` element and returns event binding\n * object to unregister event\n */\nfunction addEvent(target, type, listener, host, scope) {\n    return registerBinding(type, { host, scope, target, listener, handleEvent });\n}\n/**\n * Unregister given event binding\n */\nfunction removeEvent(type, binding) {\n    binding.target.removeEventListener(type, binding);\n}\n/**\n * Creates structure for collecting pending events\n */\nfunction pendingEvents(host, target) {\n    return { host, target, events: obj() };\n}\nfunction setPendingEvent(pending, type, listener, scope) {\n    let binding = pending.events[type];\n    if (binding) {\n        binding.listener = listener;\n        binding.scope = scope;\n    }\n    else {\n        binding = pending.events[type] = addEvent(pending.target, type, listener, pending.host, scope);\n    }\n    binding.pending = listener;\n}\nfunction finalizePendingEvents(pending) {\n    // For event listeners, we should only bind or unbind events, depending\n    // on current listener value\n    const { events } = pending;\n    for (const type in events) {\n        const binding = events[type];\n        if (binding) {\n            if (!binding.pending) {\n                events[type] = removeEvent(type, binding);\n            }\n            binding.pending = void 0;\n        }\n    }\n}\nfunction detachPendingEvents(pending) {\n    const { events } = pending;\n    for (const type in events) {\n        const binding = events[type];\n        if (binding) {\n            removeEvent(type, binding);\n        }\n    }\n}\nfunction handleEvent(event) {\n    try {\n        this.listener && this.listener(this.host, event, this.target, this.scope);\n    }\n    catch (error) {\n        runtimeError(this.host, error);\n        // tslint:disable-next-line:no-console\n        console.error(error);\n    }\n}\nfunction safeEventListener(host, handler) {\n    // tslint:disable-next-line:only-arrow-functions\n    return function (event) {\n        try {\n            handler.call(this, event);\n        }\n        catch (error) {\n            runtimeError(host, error);\n            // tslint:disable-next-line:no-console\n            console.error(error);\n        }\n    };\n}\nfunction registerBinding(type, binding) {\n    binding.target.addEventListener(type, binding);\n    return binding;\n}\n\n/** Base object to create pending namespaced attribute set */\nconst nsProto = obj();\n/**\n * Create pending props change set\n */\nfunction propsSet(elem, initial) {\n    const base = obj(elem.componentModel.defaultProps);\n    return initial ? assign(base, initial) : base;\n}\n/**\n * Alias for `elem.setAttribute`\n */\nfunction setAttribute(elem, name, value) {\n    elem.setAttribute(name, value);\n    return value;\n}\n/**\n * Updates element’s `name` attribute value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateAttribute(elem, prev, name, value) {\n    if (value !== prev[name]) {\n        const primitive = representedValue(value);\n        if (primitive === null) {\n            elem.removeAttribute(name);\n        }\n        else {\n            setAttribute(elem, name, primitive);\n        }\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Alias for `elem.className`\n */\nfunction setClass(elem, value) {\n    elem.className = value;\n    return value;\n}\n/**\n * Shorthand to update class name, specific to Endorphin compiled code\n */\nfunction updateClass(elem, prev, value) {\n    return updateAttribute(elem, prev, 'class', value === '' ? undefined : value);\n}\n/**\n * Sets attribute value as expression. Unlike regular primitive attributes,\n * expression values must be represented, e.g. non-primitive values must be\n * converted to string representations. Also, expression resolved to `false`,\n * `null` or `undefined` will remove attribute from element\n */\nfunction setAttributeExpression(elem, name, value) {\n    const primitive = representedValue(value);\n    primitive === null\n        ? elem.removeAttribute(name)\n        : setAttribute(elem, name, primitive);\n    return value;\n}\n/**\n * Alias for `elem.setAttributeNS`\n */\nfunction setAttributeNS(elem, ns, name, value) {\n    elem.setAttributeNS(ns, name, value);\n    return value;\n}\n/**\n * Updates element’s `name` attribute value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateAttributeNS(elem, prevNS, ns, name, value) {\n    const prev = ns in prevNS ? prevNS[ns] : (prevNS[ns] = obj());\n    if (value !== prev[name]) {\n        const primitive = representedValue(value);\n        if (primitive === null) {\n            elem.removeAttributeNS(ns, name);\n        }\n        else {\n            setAttributeNS(elem, ns, name, primitive);\n        }\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Same as `setAttributeExpression()` but for namespaced attributes\n */\nfunction setAttributeExpressionNS(elem, ns, name, value) {\n    const primitive = representedValue(value);\n    primitive === null\n        ? elem.removeAttributeNS(ns, name)\n        : setAttributeNS(elem, ns, name, primitive);\n    return value;\n}\n/**\n * Sets pending namespaced attribute value which will be added to element later\n */\nfunction setPendingAttributeNS(attrs, ns, name, value) {\n    const map = pendingNS(attrs, ns);\n    map[name] = value;\n}\n/**\n * Updates pending `name` value only if given `value` is not null\n */\nfunction updatePendingAttribute(attrs, name, value) {\n    if (value != null) {\n        attrs[name] = value;\n    }\n}\n/**\n * Updates pending namespaced `name` value only if given `value` is not null\n */\nfunction updatePendingAttributeNS(attrs, ns, name, value) {\n    if (value != null) {\n        pendingNS(attrs, ns)[name] = value;\n    }\n}\n/**\n * Adds given class name to pending attribute set\n */\nfunction addPendingClass(data, className) {\n    if (className != null) {\n        const prev = data.class;\n        data.class = prev ? prev + ' ' + className : String(className);\n    }\n}\n/**\n * Adds given class name to pending attribute set if condition is truthy\n */\nfunction addPendingClassIf(data, className, condition) {\n    condition && addPendingClass(data, className);\n}\n/**\n * Finalizes pending attributes\n */\nfunction finalizeAttributes(elem, cur, prev) {\n    let updated = 0;\n    for (const key in cur) {\n        const curValue = cur[key];\n        if (isPendingNS(curValue)) {\n            // It’s a pending attribute set\n            const prevNS = pendingNS(prev, key);\n            for (const name in curValue) {\n                const curNS = curValue[name];\n                if (curNS !== prevNS[name]) {\n                    updated = 1;\n                    setAttributeExpressionNS(elem, key, name, curNS);\n                    prevNS[name] = curNS;\n                }\n                curValue[name] = null;\n            }\n        }\n        else {\n            if (curValue !== prev[key]) {\n                updated = 1;\n                if (key === 'class') {\n                    elem.className = classNames(curValue);\n                }\n                else {\n                    setAttributeExpression(elem, key, curValue);\n                }\n                prev[key] = curValue;\n            }\n            cur[key] = null;\n        }\n    }\n    return updated;\n}\n/**\n * Returns normalized list of class names from given string\n */\nfunction classNames(str) {\n    if (isDefined(str)) {\n        return String(str).split(/\\s+/).filter(uniqueClassFilter).join(' ');\n    }\n    return '';\n}\n/**\n * Returns value for <input> element\n */\nfunction inputValue(value) {\n    return value != null ? value : '';\n}\n/**\n * Updates element’s `name` property value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateProperty(elem, prev, name, value) {\n    if (value !== prev[name]) {\n        elem[name] = name === 'value' ? inputValue(value) : value;\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns represented attribute value for given data\n */\nfunction representedValue(value) {\n    if (value === false || !isDefined(value)) {\n        return null;\n    }\n    if (value === true) {\n        return '';\n    }\n    if (Array.isArray(value)) {\n        return '[]';\n    }\n    if (typeof value === 'function') {\n        return '𝑓';\n    }\n    if (typeof value === 'object') {\n        return '{}';\n    }\n    return value;\n}\n/**\n * Check if given object is a pending namespaced attribute set\n */\nfunction isPendingNS(data) {\n    return data != null && typeof data === 'object' && Object.getPrototypeOf(data) === nsProto;\n}\n/**\n * Ensures given attribute value map contains namespace map for given `ns` and\n * returns it\n */\nfunction pendingNS(attrs, ns) {\n    return ns in attrs ? attrs[ns] : (attrs[ns] = Object.create(nsProto));\n}\nfunction uniqueClassFilter(cl, index, arr) {\n    return cl ? arr.indexOf(cl) === index : false;\n}\n\n/**\n * Creates linted list\n */\n/**\n * Creates linked list item\n */\nfunction createListItem(value) {\n    return { value, next: null, prev: null };\n}\n/**\n * Prepends given value to linked list\n */\nfunction listPrependValue(list, value) {\n    const item = createListItem(value);\n    if (item.next = list.head) {\n        item.next.prev = item;\n    }\n    return list.head = item;\n}\n/**\n * Inserts given value after given `ref` item\n */\nfunction listInsertValueAfter(value, ref) {\n    const item = createListItem(value);\n    const { next } = ref;\n    ref.next = item;\n    item.prev = ref;\n    if (item.next = next) {\n        next.prev = item;\n    }\n    return item;\n}\n/**\n * Moves list fragment with `start` and `end` bounds right after `ref` item\n */\nfunction listMoveFragmentAfter(list, start, end, ref) {\n    listDetachFragment(list, start, end);\n    if (end.next = ref.next) {\n        end.next.prev = end;\n    }\n    ref.next = start;\n    start.prev = ref;\n}\n/**\n * Moves list fragment with `start` and `end` to list head\n */\nfunction listMoveFragmentFirst(list, start, end) {\n    listDetachFragment(list, start, end);\n    if (end.next = list.head) {\n        end.next.prev = end;\n    }\n    list.head = start;\n}\n/**\n * Detaches list fragment with `start` and `end` from list\n */\nfunction listDetachFragment(list, start, end) {\n    const { prev } = start;\n    const { next } = end;\n    if (prev) {\n        prev.next = next;\n    }\n    else {\n        list.head = next;\n    }\n    if (next) {\n        next.prev = prev;\n    }\n    start.prev = end.next = null;\n}\n\n/**\n * Creates injector instance for given target, if required\n */\nfunction createInjector(target) {\n    return {\n        parentNode: target,\n        head: null,\n        ptr: null,\n        // NB create `slots` placeholder to promote object to hidden class.\n        // Do not use any additional function argument for adding value to `slots`\n        // to reduce runtime checks and keep functions in monomorphic state\n        slots: null\n    };\n}\n/**\n * Inserts given node into current context\n */\nfunction insert(injector, node, slotName = '') {\n    const { slots, ptr } = injector;\n    const target = slots\n        ? getSlotContext(injector, slotName).element\n        : injector.parentNode;\n    domInsert(node, target, ptr ? getAnchorNode(ptr.next, target) : void 0);\n    injector.ptr = ptr ? listInsertValueAfter(node, ptr) : listPrependValue(injector, node);\n    return node;\n}\n/**\n * Injects given block\n */\nfunction injectBlock(injector, block) {\n    const { ptr } = injector;\n    if (ptr) {\n        block.end = listInsertValueAfter(block, ptr);\n        block.start = listInsertValueAfter(block, ptr);\n    }\n    else {\n        block.end = listPrependValue(injector, block);\n        block.start = listPrependValue(injector, block);\n    }\n    injector.ptr = block.end;\n    return block;\n}\n/**\n * Returns named slot context from given component input’s injector. If slot context\n * doesn’t exists, it will be created\n */\nfunction getSlotContext(injector, name) {\n    const slots = injector.slots;\n    return slots[name] || (slots[name] = createSlotContext(name));\n}\n/**\n * Empties content of given block\n * @param detached Empty block in detached state. Detached state means one of the\n * parent DOM element will be removed from document so there’s no need to detach\n * inner DOM elements\n */\nfunction emptyBlockContent(block, detached) {\n    const unmount = block.mount && block.mount.dispose;\n    if (unmount) {\n        unmount(block.scope, block.host);\n    }\n    let item = block.start.next;\n    while (item && item !== block.end) {\n        // tslint:disable-next-line:prefer-const\n        let { value, next, prev } = item;\n        if (!isElement(value)) {\n            next = value.end.next;\n            disposeBlock(value);\n        }\n        else if (!detached && !value[animatingKey]) {\n            domRemove(value);\n        }\n        // NB: Block always contains `.next` and `.prev` items which are block\n        // bounds so we can safely skip null check here\n        prev.next = next;\n        next.prev = prev;\n        item = next;\n    }\n}\n/**\n * Moves contents of `block` after `ref` list item\n */\nfunction move(injector, block, ref) {\n    if (ref && ref.next && ref.next.value === block) {\n        return;\n    }\n    // Update linked list\n    const { start, end } = block;\n    if (ref) {\n        listMoveFragmentAfter(injector, start, end, ref);\n    }\n    else {\n        listMoveFragmentFirst(injector, start, end);\n    }\n    // Move block contents in DOM\n    let item = start.next;\n    let node;\n    while (item && item !== end) {\n        if (isElement(item.value)) {\n            node = item.value;\n            // NB it’s possible that a single block contains nodes from different\n            // slots so we have to find anchor for each node individually\n            domInsert(node, node.parentNode, getAnchorNode(end.next, node.parentNode));\n        }\n        item = item.next;\n    }\n}\n/**\n * Disposes given block\n */\nfunction disposeBlock(block, detached) {\n    emptyBlockContent(block, detached);\n    listDetachFragment(block.injector, block.start, block.end);\n    // @ts-ignore: Nulling disposed object\n    block.start = block.end = block.scope = null;\n}\nfunction isElement(obj) {\n    return 'nodeType' in obj;\n}\n/**\n * Get DOM node nearest to given position of items list\n */\nfunction getAnchorNode(item, parent) {\n    while (item) {\n        if (item.value.parentNode === parent) {\n            return item.value;\n        }\n        item = item.next;\n    }\n}\n/**\n * Creates context for given slot\n */\nfunction createSlotContext(name) {\n    const element = document.createElement('slot');\n    name && element.setAttribute('name', name);\n    return {\n        name,\n        element,\n        isDefault: false,\n        defaultContent: null\n    };\n}\n\n/**\n * Invokes `name` hook for given component definition\n */\nfunction runHook(component, name, arg1, arg2) {\n    const { plugins } = component.componentModel;\n    for (let i = plugins.length - 1, hook; i >= 0; i--) {\n        hook = plugins[i][name];\n        if (typeof hook === 'function') {\n            try {\n                hook(component, arg1, arg2);\n            }\n            catch (error) {\n                runtimeError(component, error);\n                // tslint:disable-next-line:no-console\n                console.error(error);\n            }\n        }\n    }\n}\n\n/**\n * Enters new variable scope context\n */\nfunction enterScope(host, incoming) {\n    return setScope(host, createScope(host, incoming));\n}\n/**\n * Exit from current variable scope\n */\nfunction exitScope(host) {\n    return setScope(host, Object.getPrototypeOf(host.componentModel.vars));\n}\n/**\n * Creates new scope from given component state\n */\nfunction createScope(host, incoming) {\n    return assign(obj(host.componentModel.vars), incoming);\n}\n/**\n * Sets given object as current component scope\n */\nfunction setScope(host, scope) {\n    return host.componentModel.vars = scope;\n}\n/**\n * Returns current variable scope\n */\nfunction getScope(elem) {\n    return elem.componentModel.vars;\n}\n/**\n * Returns property with given name from component\n */\nfunction getProp(elem, name) {\n    return elem.props[name];\n}\n/**\n * Returns state value with given name from component\n */\nfunction getState(elem, name) {\n    return elem.state[name];\n}\n/**\n * Returns value of given runtime variable from component\n */\nfunction getVar(elem, name) {\n    return elem.componentModel.vars[name];\n}\n/**\n * Sets value of given runtime variable for component\n */\nfunction setVar(elem, name, value) {\n    elem.componentModel.vars[name] = value;\n}\n\n/**\n * Creates slot element\n */\nfunction createSlot(host, name, cssScope) {\n    const el = getSlotContext(host.componentModel.input, name).element;\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Mounts slot context\n */\nfunction mountSlot(host, name, defaultContent) {\n    const { input } = host.componentModel;\n    const ctx = getSlotContext(input, name);\n    const injector = createInjector(ctx.element);\n    if (defaultContent) {\n        // Add block with default slot content\n        ctx.defaultContent = injectBlock(injector, {\n            host,\n            injector,\n            scope: getScope(host),\n            content: defaultContent,\n            mount: void 0,\n            update: void 0\n        });\n    }\n    if (isEmpty(ctx)) {\n        // No incoming content, mount default content\n        renderDefaultContent(ctx);\n    }\n    else {\n        setSlotted(ctx, true);\n    }\n    return ctx;\n}\n/**\n * Handles possible update of incoming data\n */\nfunction updateIncomingSlot(host, name, updated) {\n    const ctx = getSlotContext(host.componentModel.input, name);\n    if (updated) {\n        // Incoming content was updated but there’s default content mounted\n        if (ctx.isDefault) {\n            const block = ctx.defaultContent;\n            if (block) {\n                emptyBlockContent(block);\n                block.mount = void 0;\n            }\n            setSlotted(ctx, true);\n        }\n        notifySlotUpdate(host, ctx);\n    }\n    if (!ctx.isDefault && isEmpty(ctx)) {\n        // If slot content is empty, ensure default content is rendered\n        renderDefaultContent(ctx);\n    }\n}\n/**\n * Updates default slot content only if it was already rendered\n */\nfunction updateDefaultSlot(ctx) {\n    if (ctx.isDefault) {\n        const block = ctx.defaultContent;\n        if (block.update) {\n            block.update(block.host, block.scope);\n        }\n    }\n}\n/**\n * Unmounts default content of given slot context\n */\nfunction unmountSlot(ctx) {\n    const block = ctx.defaultContent;\n    if (block) {\n        disposeBlock(block);\n        setSlotted(ctx, false);\n        ctx.isDefault = false;\n        ctx.defaultContent = null;\n    }\n}\nfunction notifySlotUpdate(host, ctx) {\n    runHook(host, 'didSlotUpdate', ctx.name, ctx.element);\n}\n/**\n * Renders default slot content\n */\nfunction renderDefaultContent(ctx) {\n    if (ctx.defaultContent) {\n        const block = ctx.defaultContent;\n        const { injector } = block;\n        injector.ptr = block.start;\n        block.mount = block.content;\n        block.update = block.mount(block.host, injector, block.scope);\n        injector.ptr = block.end;\n    }\n    setSlotted(ctx, false);\n}\n/**\n * Check if given slot is empty\n */\nfunction isEmpty(ctx) {\n    // TODO better check for input content?\n    return !ctx.element.childNodes.length;\n}\n/**\n * Toggles slotted state in slot container\n */\nfunction setSlotted(ctx, slotted) {\n    ctx.isDefault = !slotted;\n    slotted ? ctx.element.setAttribute('slotted', '') : ctx.element.removeAttribute('slotted');\n}\n\nlet renderQueue = null;\n/** A lookup of normalized attributes */\nconst attributeLookup = {};\n/**\n * Creates Endorphin DOM component with given definition\n */\nfunction createComponent(name, definition, host) {\n    let cssScope;\n    let root;\n    if (host && 'componentModel' in host) {\n        cssScope = host.componentModel.definition.cssScope;\n        root = host.root || host;\n    }\n    const element = elem(name, cssScope);\n    return createComponentFromElement(element, definition, root);\n}\n/**\n * Convert HTMLElement into Endorphin DOM component with given definition\n */\nfunction createComponentFromElement(el, definition, root) {\n    const element = el;\n    // Add host scope marker: we can’t rely on tag name since component\n    // definition is bound to element in runtime, not compile time\n    if (definition.cssScope) {\n        element.setAttribute(definition.cssScope + '-host', '');\n    }\n    const { props, state, extend, events, plugins } = prepare(element, definition);\n    element.refs = obj();\n    element.props = obj();\n    element.state = state;\n    element.componentView = element; // XXX Should point to Shadow Root in Web Components\n    root && (element.root = root);\n    addPropsState(element);\n    if (extend) {\n        Object.defineProperties(element, extend);\n    }\n    if (definition.store) {\n        element.store = definition.store();\n    }\n    else if (root && root.store) {\n        element.store = root.store;\n    }\n    // Create slotted input\n    const input = createInjector(element.componentView);\n    input.slots = obj();\n    element.componentModel = {\n        definition,\n        input,\n        vars: obj(),\n        mounted: false,\n        preparing: false,\n        update: void 0,\n        queued: false,\n        events,\n        plugins,\n        partialDeps: null,\n        defaultProps: props\n    };\n    runHook(element, 'init');\n    return element;\n}\n/**\n * Mounts given component\n */\nfunction mountComponent(component, props) {\n    const { componentModel } = component;\n    const { input, definition } = componentModel;\n    const changes = setPropsInternal(component, props || componentModel.defaultProps);\n    const arg = changes || {};\n    componentModel.preparing = true;\n    // Notify slot status\n    for (const p in input.slots) {\n        notifySlotUpdate(component, input.slots[p]);\n    }\n    if (changes) {\n        runHook(component, 'didChange', arg);\n    }\n    runHook(component, 'willMount', arg);\n    runHook(component, 'willRender', arg);\n    componentModel.preparing = false;\n    componentModel.update = captureError(component, definition.default, component, getScope(component));\n    componentModel.mounted = true;\n    runHook(component, 'didRender', arg);\n    runHook(component, 'didMount', arg);\n}\n/**\n * Updates given mounted component\n */\nfunction updateComponent(component, props, partialDeps) {\n    const { componentModel } = component;\n    let changes = props && setPropsInternal(component, props);\n    if (partialDeps) {\n        if (!changes && partialDepsUpdated(componentModel.partialDeps, partialDeps)) {\n            changes = obj();\n        }\n        componentModel.partialDeps = partialDeps;\n    }\n    if (changes || componentModel.queued) {\n        renderNext(component, changes);\n    }\n    return changes ? 1 : 0;\n}\n/**\n * Destroys given component: removes static event listeners and cleans things up\n * @returns Should return nothing since function result will be used\n * as shorthand to reset cached value\n */\nfunction unmountComponent(component) {\n    const { componentModel } = component;\n    const { definition, events } = componentModel;\n    runHook(component, 'willUnmount');\n    componentModel.mounted = false;\n    if (events) {\n        detachStaticEvents(component, events);\n    }\n    if (component.store) {\n        component.store.unwatch(component);\n    }\n    const dispose = definition.default && definition.default.dispose;\n    captureError(component, dispose, getScope(component));\n    runHook(component, 'didUnmount');\n    // @ts-ignore: Nulling disposed object\n    component.componentModel = null;\n}\n/**\n * Subscribes to store updates of given component\n */\nfunction subscribeStore(component, keys) {\n    if (!component.store) {\n        throw new Error(`Store is not defined for ${component.nodeName} component`);\n    }\n    component.store.watch(component, keys);\n}\n/**\n * Queues next component render\n */\nfunction renderNext(component, changes) {\n    if (!component.componentModel.preparing) {\n        renderComponent(component, changes);\n    }\n    else {\n        scheduleRender(component, changes);\n    }\n}\n/**\n * Schedules render of given component on next tick\n */\nfunction scheduleRender(component, changes) {\n    if (!component.componentModel.queued) {\n        component.componentModel.queued = true;\n        if (renderQueue) {\n            renderQueue.push(component, changes);\n        }\n        else {\n            renderQueue = [component, changes];\n            requestAnimationFrame(drainQueue);\n        }\n    }\n}\n/**\n * Renders given component\n */\nfunction renderComponent(component, changes) {\n    const { componentModel } = component;\n    const arg = changes || {};\n    componentModel.queued = false;\n    componentModel.preparing = true;\n    if (changes) {\n        runHook(component, 'didChange', arg);\n    }\n    runHook(component, 'willUpdate', arg);\n    runHook(component, 'willRender', arg);\n    componentModel.preparing = false;\n    captureError(component, componentModel.update, component, getScope(component));\n    runHook(component, 'didRender', arg);\n    runHook(component, 'didUpdate', arg);\n}\n/**\n * Removes attached events from given map\n */\nfunction detachStaticEvents(component, eventMap) {\n    const { listeners, handler } = eventMap;\n    for (const p in listeners) {\n        component.removeEventListener(p, handler);\n    }\n}\nfunction kebabCase(ch) {\n    return '-' + ch.toLowerCase();\n}\nfunction setPropsInternal(component, nextProps) {\n    let changes;\n    const { props } = component;\n    const { defaultProps } = component.componentModel;\n    let prev;\n    let current;\n    for (const p in nextProps) {\n        prev = props[p];\n        current = nextProps[p];\n        if (current == null && p in defaultProps) {\n            current = defaultProps[p];\n        }\n        if (p === 'class' && current != null) {\n            current = classNames(current);\n        }\n        if (current !== prev) {\n            if (!changes) {\n                changes = obj();\n            }\n            props[p] = current;\n            changes[p] = { current, prev };\n            if (!/^partial:/.test(p)) {\n                setAttributeExpression(component, normalizeAttribute(p), current);\n            }\n        }\n    }\n    return changes;\n}\n/**\n * Check if `next` contains value that differs from one in `prev`\n */\nfunction hasChanges(prev, next) {\n    for (const p in next) {\n        if (next[p] !== prev[p]) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Prepares internal data for given component\n */\nfunction prepare(component, definition) {\n    const props = obj();\n    const state = obj();\n    const plugins = collectPlugins(component, definition, [definition]);\n    let events;\n    let extend;\n    for (let i = plugins.length - 1; i >= 0; i--) {\n        const dfn = plugins[i];\n        dfn.props && assign(props, dfn.props(component));\n        dfn.state && assign(state, dfn.state(component));\n        // NB: backward compatibility with previous implementation\n        if (dfn.methods) {\n            extend = getDescriptors(dfn.methods, extend);\n        }\n        if (dfn.extend) {\n            extend = getDescriptors(dfn.extend, extend);\n        }\n        if (dfn.events) {\n            if (!events) {\n                events = createEventsMap(component);\n            }\n            attachEventHandlers(component, dfn.events, events);\n        }\n    }\n    return { props, state, extend, events, plugins };\n}\n/**\n * Collects all plugins (including nested) into a flat list\n */\nfunction collectPlugins(component, definition, dest = []) {\n    let { plugins } = definition;\n    if (typeof plugins === 'function') {\n        plugins = plugins(component);\n    }\n    if (Array.isArray(plugins)) {\n        for (let i = 0; i < plugins.length; i++) {\n            dest.push(plugins[i]);\n            collectPlugins(component, plugins[i], dest);\n        }\n    }\n    return dest;\n}\n/**\n * Extracts property descriptors from given source object and merges it with `prev`\n * descriptor map, if given\n */\nfunction getDescriptors(source, prev) {\n    const descriptors = getObjectDescriptors(source);\n    return prev ? assign(prev, descriptors) : descriptors;\n}\nfunction createEventsMap(component) {\n    const listeners = obj();\n    const handler = function (evt) {\n        if (component.componentModel) {\n            const handlers = listeners[evt.type];\n            for (let i = 0; i < handlers.length; i++) {\n                handlers[i](component, evt, this);\n            }\n        }\n    };\n    return { handler: safeEventListener(component, handler), listeners };\n}\nfunction attachEventHandlers(component, events, eventMap) {\n    const names = Object.keys(events);\n    const { listeners } = eventMap;\n    for (let i = 0, name; i < names.length; i++) {\n        name = names[i];\n        if (name in listeners) {\n            listeners[name].push(events[name]);\n        }\n        else {\n            component.addEventListener(name, eventMap.handler);\n            listeners[name] = [events[name]];\n        }\n    }\n}\nfunction addPropsState(element) {\n    element.setProps = function setProps(value) {\n        const { componentModel } = element;\n        // In case of calling `setProps` after component was unmounted,\n        // check if `componentModel` is available\n        if (value != null && componentModel && componentModel.mounted) {\n            const changes = setPropsInternal(element, assign(obj(), value));\n            changes && renderNext(element, changes);\n            return changes;\n        }\n    };\n    element.setState = function setState(value) {\n        const { componentModel } = element;\n        // In case of calling `setState` after component was unmounted,\n        // check if `componentModel` is available\n        if (value != null && componentModel && hasChanges(element.state, value)) {\n            assign(element.state, value);\n            // If we’re in rendering state than current `setState()` is caused by\n            // one of the `will*` hooks, which means applied changes will be automatically\n            // applied during rendering stage.\n            // If called outside of rendering state we should schedule render\n            // on next tick\n            if (componentModel.mounted && !componentModel.preparing) {\n                scheduleRender(element);\n            }\n        }\n    };\n}\nfunction drainQueue() {\n    const pending = renderQueue;\n    renderQueue = null;\n    for (let i = 0, component; i < pending.length; i += 2) {\n        component = pending[i];\n        // It’s possible that a component can be rendered before next tick\n        // (for example, if parent node updated component props).\n        // Check if it’s still queued then render.\n        // Also, component can be unmounted after it’s rendering was scheduled\n        if (component.componentModel && component.componentModel.queued) {\n            renderComponent(component, pending[i + 1]);\n        }\n    }\n}\n/**\n * Normalizes given attribute name: converts `camelCase` to `kebab-case`\n */\nfunction normalizeAttribute(attr) {\n    if (!(attr in attributeLookup)) {\n        attributeLookup[attr] = attr.replace(/[A-Z]/g, kebabCase);\n    }\n    return attributeLookup[attr];\n}\n/**\n * Check if partial dependencies of component were updated\n */\nfunction partialDepsUpdated(prev, next) {\n    if (!prev) {\n        return true;\n    }\n    // In compiler, deps will always have the same length\n    for (let i = 0; i < prev.length; i++) {\n        if (prev[i] !== next[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction mountBlock(host, injector, get) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        mount: undefined,\n        update: undefined\n    });\n    updateBlock(block);\n    return block;\n}\n/**\n * Updated block, described in `ctx` object\n * @returns Returns `1` if block was updated, `0` otherwise\n */\nfunction updateBlock(block) {\n    let updated = 0;\n    const { host, injector, scope } = block;\n    const mount = block.get(host, scope);\n    if (block.mount !== mount) {\n        updated = 1;\n        // Unmount previously rendered content\n        block.mount && emptyBlockContent(block);\n        // Mount new block content\n        injector.ptr = block.start;\n        block.mount = mount;\n        block.update = mount && mount(block.host, injector, scope);\n    }\n    else if (block.update) {\n        // Update rendered result\n        updated = block.update(host, scope) ? 1 : 0;\n    }\n    block.injector.ptr = block.end;\n    return updated;\n}\nfunction unmountBlock(block) {\n    disposeBlock(block);\n}\nfunction clearBlock(block) {\n    disposeBlock(block, true);\n}\n\n/**\n * Mounts iterator block\n * @param get A function that returns collection to iterate\n * @param body A function that renders item of iterated collection\n */\nfunction mountIterator(host, injector, get, body) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        body,\n        index: 0,\n        updated: 0\n    });\n    updateIterator(block);\n    return block;\n}\n/**\n * Updates iterator block defined in `ctx`\n * @returns Returns `1` if iterator was updated, `0` otherwise\n */\nfunction updateIterator(block) {\n    const { injector } = block;\n    injector.ptr = block.start;\n    block.index = block.updated = 0;\n    const collection = block.get(block.host, block.scope);\n    if (collection && typeof collection.forEach === 'function') {\n        collection.forEach(iterator, block);\n    }\n    trimIteratorItems(block, injector.ptr.next);\n    injector.ptr = block.end;\n    return block.updated;\n}\nfunction unmountIterator(block) {\n    disposeBlock(block);\n}\nfunction clearIterator(block) {\n    disposeBlock(block, true);\n}\nfunction prepareScope(scope, index, key, value) {\n    scope.index = index;\n    scope.key = key;\n    scope.value = value;\n    return scope;\n}\n/**\n * Removes remaining iterator items from current context\n */\nfunction trimIteratorItems(block, start) {\n    let listItem;\n    while (start !== block.end) {\n        block.updated = 1;\n        listItem = start.value;\n        start = listItem.end.next;\n        disposeBlock(listItem);\n    }\n}\nfunction iterator(value, key) {\n    const { host, injector, index, body, end } = this;\n    const { next } = injector.ptr;\n    const prevScope = getScope(host);\n    let rendered;\n    if (next !== end) {\n        rendered = next.value;\n        // We have rendered item, update it\n        if (rendered.update) {\n            const scope = prepareScope(rendered.scope, index, key, value);\n            setScope(host, scope);\n            if (rendered.update(host, scope)) {\n                this.updated = 1;\n            }\n            setScope(host, prevScope);\n        }\n    }\n    else {\n        // Create & render new block\n        const scope = prepareScope(obj(prevScope), index, key, value);\n        rendered = injectBlock(injector, {\n            host,\n            injector,\n            scope,\n            mount: body,\n            update: undefined,\n        });\n        setScope(host, scope);\n        injector.ptr = rendered.start;\n        rendered.update = body(host, injector, scope);\n        setScope(host, prevScope);\n        this.updated = 1;\n    }\n    injector.ptr = rendered.end;\n    this.index++;\n}\n\n/**\n * Renders key iterator block\n */\nfunction mountKeyIterator(host, injector, get, keyExpr, body) {\n    const parentScope = getScope(host);\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: obj(parentScope),\n        get,\n        body,\n        keyExpr,\n        index: 0,\n        updated: 0,\n        used: null,\n        rendered: null,\n        needReorder: false,\n        parentScope,\n        order: []\n    });\n    updateKeyIterator(block);\n    return block;\n}\n/**\n * Updates iterator block defined in `ctx`\n * @returns Returns `1` if iterator was updated, `0` otherwise\n */\nfunction updateKeyIterator(block) {\n    const { host, injector, rendered } = block;\n    injector.ptr = block.start;\n    block.used = obj();\n    block.index = block.updated = 0;\n    block.needReorder = false;\n    const collection = block.get(host, block.parentScope);\n    if (collection && typeof collection.forEach === 'function') {\n        const prevScope = getScope(host);\n        collection.forEach(keyIterator, block);\n        setScope(host, prevScope);\n    }\n    if (rendered) {\n        block.updated |= disposeLookup(rendered);\n    }\n    if (block.needReorder) {\n        block.updated = 1;\n        reorder(block);\n    }\n    block.order.length = 0;\n    block.rendered = block.used;\n    injector.ptr = block.end;\n    return block.updated;\n}\nfunction unmountKeyIterator(block) {\n    disposeBlock(block);\n}\nfunction clearKeyIterator(block) {\n    disposeBlock(block, true);\n}\nfunction getItem(listItem, bound) {\n    return listItem !== bound ? listItem.value : null;\n}\nfunction keyIterator(value, key) {\n    const { injector, index, rendered } = this;\n    const id = this.keyExpr(value, prepareScope(this.scope, index, key, value));\n    let entry = rendered && getLookup(rendered, id);\n    if (entry) {\n        if (entry.start.prev !== injector.ptr) {\n            this.needReorder = true;\n        }\n        this.updated |= updateEntry(entry, value, key, index);\n    }\n    else {\n        entry = mountEntry(this, value, key, index);\n        this.updated = 1;\n    }\n    putLookup(this.used, id, entry);\n    this.order.push(entry);\n    injector.ptr = entry.end;\n    this.index++;\n}\nfunction mountEntry(block, value, key, index) {\n    const { host, injector, body: mount } = block;\n    const scope = prepareScope(obj(block.scope), index, key, value);\n    setScope(host, scope);\n    const entry = injectBlock(injector, {\n        host,\n        injector,\n        scope,\n        mount,\n        update: undefined,\n        next: null\n    });\n    injector.ptr = entry.start;\n    entry.update = mount && mount(host, injector, scope);\n    return entry;\n}\nfunction updateEntry(entry, value, key, index) {\n    if (entry.update) {\n        const { host } = entry;\n        const scope = prepareScope(entry.scope, index, key, value);\n        setScope(host, scope);\n        if (entry.update(host, scope)) {\n            return 1;\n        }\n    }\n    return 0;\n}\nfunction reorder(block) {\n    const { injector, order } = block;\n    let actualPrev;\n    let actualNext;\n    let expectedPrev;\n    let expectedNext;\n    const { start, end } = block;\n    for (let i = 0, maxIx = order.length - 1, item; i <= maxIx; i++) {\n        item = order[i];\n        expectedPrev = i > 0 ? order[i - 1] : null;\n        expectedNext = i < maxIx ? order[i + 1] : null;\n        actualPrev = getItem(item.start.prev, start);\n        actualNext = getItem(item.end.next, end);\n        if (expectedPrev !== actualPrev || expectedNext !== actualNext) {\n            // Blocks must be reordered\n            move(injector, item, expectedPrev ? expectedPrev.end : block.start);\n        }\n    }\n}\nfunction getLookup(lookup, key) {\n    const item = lookup[key];\n    if (item && (lookup[key] = item.next)) {\n        item.next = null;\n    }\n    return item;\n}\nfunction putLookup(lookup, key, value) {\n    value.next = lookup[key];\n    lookup[key] = value;\n}\nfunction disposeLookup(lookup) {\n    let updated = 0;\n    for (const p in lookup) {\n        let item = lookup[p];\n        while (item) {\n            updated = 1;\n            disposeBlock(item);\n            item = item.next;\n        }\n    }\n    return updated;\n}\n\n/**\n * Adds given element as a named ref\n */\nfunction setRef(host, key, elem) {\n    elem.setAttribute(getRefAttr(key, host), '');\n    host.refs[key] = elem;\n}\n/**\n * Removes ref for given key\n */\nfunction removeRef(host, key) {\n    // NB: Do not remove ref attribute in order to keep CSS styles for animated\n    // ref’ed element (`animate:out`). In case if its introduces unexpected side\n    // effects, update compiler to properly unmount refs but keep HTML attribute\n    // for animated elements\n    // const elem = host.refs[key];\n    // if (elem) {\n    // \telem.removeAttribute(getRefAttr(key, host));\n    // }\n    host.refs[key] = null;\n}\nfunction setPendingRef(pending, key, elem) {\n    if (key && elem) {\n        pending[key] = elem;\n    }\n}\nfunction finalizePendingRefs(host, pending) {\n    for (const key in pending) {\n        const prev = host.refs[key];\n        const next = pending[key];\n        if (prev !== next) {\n            prev && removeRef(host, key);\n            next && setRef(host, key, next);\n        }\n        pending[key] = null;\n    }\n}\n/**\n * Returns attribute name to identify element in CSS\n */\nfunction getRefAttr(name, host) {\n    const cssScope = host.componentModel.definition.cssScope;\n    return 'ref-' + name + (cssScope ? '-' + cssScope : '');\n}\n\n/**\n * Renders code, returned from `get` function, as HTML\n */\nfunction mountInnerHTML(host, injector, get, slotName) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        code: null,\n        slotName\n    });\n    updateInnerHTML(block);\n    return block;\n}\n/**\n * Updates inner HTML of block, defined in `ctx`\n * @returns Returns `1` if inner HTML was updated, `0` otherwise\n */\nfunction updateInnerHTML(block) {\n    const { host, injector, scope } = block;\n    const code = block.get(host, scope);\n    if (code !== block.code) {\n        emptyBlockContent(block);\n        if (isDefined(block.code = code)) {\n            injector.ptr = block.start;\n            renderHTML(host, injector, code, block.slotName);\n        }\n        injector.ptr = block.end;\n        return 1;\n    }\n    return 0;\n}\nfunction unmountInnerHTML(block) {\n    disposeBlock(block);\n}\nfunction clearInnerHTML(block) {\n    disposeBlock(block, true);\n}\nfunction renderHTML(host, injector, code, slotName) {\n    const { cssScope } = host.componentModel.definition;\n    if (isNode(code)) {\n        // Insert as DOM element\n        cssScope && scopeDOM(code, cssScope);\n        if (code.nodeType === code.DOCUMENT_FRAGMENT_NODE) {\n            // Insert document fragment contents separately to properly maintain\n            // list of inserted elements\n            while (code.firstChild) {\n                insert(injector, code.firstChild, slotName);\n            }\n        }\n        else {\n            insert(injector, code, slotName);\n        }\n    }\n    else {\n        // Render as HTML\n        const div = document.createElement('div');\n        div.innerHTML = code;\n        cssScope && scopeDOM(div, cssScope);\n        while (div.firstChild) {\n            insert(injector, div.firstChild, slotName);\n        }\n    }\n}\n/**\n * Scopes CSS of all elements in given node\n */\nfunction scopeDOM(node, cssScope) {\n    node = node.firstChild;\n    while (node) {\n        if (node.nodeType === node.ELEMENT_NODE) {\n            isolateElement(node, cssScope);\n            scopeDOM(node, cssScope);\n        }\n        node = node.nextSibling;\n    }\n}\nfunction isNode(obj) {\n    return obj && obj.nodeType;\n}\n\nfunction getPartial(host, name, componentPartials) {\n    return host.props['partial:' + name] || componentPartials[name];\n}\n/**\n * Mounts given partial into injector context\n */\nfunction mountPartial(host, injector, partial, args) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        mount: void 0,\n        update: void 0,\n        partial: null\n    });\n    updatePartial(block, partial, args);\n    return block;\n}\n/**\n * Updates mounted partial\n * @returns Returns `1` if partial was updated, `0` otherwise\n */\nfunction updatePartial(block, partial, args) {\n    const host = partial.host || block.host;\n    const { injector } = block;\n    const prevHost = block.host;\n    const prevScope = getScope(host);\n    let updated = 0;\n    block.host = host;\n    if (block.partial !== partial) {\n        // Unmount previously rendered partial\n        block.partial && emptyBlockContent(block);\n        // Mount new partial\n        const scope = block.scope = assign(obj(prevScope), partial.defaults, args);\n        setScope(host, scope);\n        injector.ptr = block.start;\n        block.mount = partial && partial.body;\n        block.update = block.mount && block.mount(host, injector, scope);\n        block.partial = partial;\n        setScope(host, prevScope);\n        updated = 1;\n    }\n    else if (block.update) {\n        // Update rendered partial\n        const scope = setScope(host, assign(block.scope, args));\n        if (block.update(host, scope)) {\n            updated = 1;\n        }\n        setScope(host, prevScope);\n    }\n    block.host = prevHost;\n    injector.ptr = block.end;\n    return updated;\n}\nfunction unmountPartial(block) {\n    disposeBlock(block);\n}\nfunction clearPartial(block) {\n    disposeBlock(block, true);\n}\n\nconst prefix = '$';\nclass Store {\n    constructor(data) {\n        this.sync = false;\n        this.listeners = [];\n        this.data = assign({}, data || {});\n    }\n    /**\n     * Returns current store data\n     */\n    get() {\n        return this.data;\n    }\n    /**\n     * Updates data in store\n     */\n    set(data) {\n        const updated = changed(data, this.data, prefix);\n        const render = this.sync ? renderComponent : scheduleRender;\n        if (updated) {\n            const next = this.data = assign(this.data, data);\n            // Notify listeners.\n            // Run in reverse order for listener safety (in case if handler decides\n            // to unsubscribe during notification)\n            for (let i = this.listeners.length - 1, item; i >= 0; i--) {\n                item = this.listeners[i];\n                if (!item.keys || !item.keys.length || hasChange(item.keys, updated)) {\n                    if ('component' in item) {\n                        render(item.component, updated);\n                    }\n                    else if ('handler' in item) {\n                        item.handler(next, updated);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Subscribes to changes in given store\n     * @param handler Function to invoke when store changes\n     * @param keys Run handler only if given top-level keys are changed\n     * @returns Object that should be used to unsubscribe from updates\n     */\n    subscribe(handler, keys) {\n        const obj = {\n            handler,\n            keys: scopeKeys(keys, prefix)\n        };\n        this.listeners.push(obj);\n        return obj;\n    }\n    /**\n     * Unsubscribes from further updates\n     */\n    unsubscribe(obj) {\n        const ix = this.listeners.indexOf(obj);\n        if (ix !== -1) {\n            this.listeners.splice(ix, 1);\n        }\n    }\n    /**\n     * Watches for updates of given `keys` in store and runs `component` render on change\n     */\n    watch(component, keys) {\n        this.listeners.push({\n            component,\n            keys: scopeKeys(keys, prefix)\n        });\n    }\n    /**\n     * Stops watching for store updates for given component\n     * @param {Component} component\n     */\n    unwatch(component) {\n        for (let i = 0; i < this.listeners.length; i++) {\n            if (this.listeners[i].component === component) {\n                this.listeners.splice(i, 1);\n            }\n        }\n    }\n}\n/**\n * Check if any of `keys` was changed in `next` object since `prev` state\n * @param {string[]} keys\n * @param {Object} updated\n * @return {boolean}\n */\nfunction hasChange(keys, updated) {\n    for (let i = 0; i < keys.length; i++) {\n        if (keys[i] in updated) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Adds given prefix to keys\n */\nfunction scopeKeys(keys, pfx) {\n    return keys && pfx ? keys.map(key => pfx + key) : keys;\n}\n\nconst pool = [];\nconst defaultTween = {\n    duration: 500,\n    delay: 0,\n    easing(t, b, c, d) {\n        return c * t / d + b;\n    }\n};\n// If `true` then no animations will be invoked\nlet blocked = false;\n/**\n * Starts animation on given element\n */\nfunction animate(elem, animation, callback) {\n    if (!blocked && animation) {\n        if (typeof animation === 'function') {\n            tweenAnimate(elem, animation, callback);\n        }\n        else {\n            cssAnimate(elem, animation, callback);\n        }\n    }\n    else if (callback) {\n        // Stop previous animation, if any\n        stopAnimation(elem, true);\n        callback();\n    }\n}\n/**\n * Starts CSS animation on given element\n */\nfunction cssAnimate(elem, animation, callback) {\n    // Stop previous animation, if any\n    stopAnimation(elem, true);\n    let timer;\n    const prevAnimation = elem.style.animation;\n    const evtPayload = {\n        animation,\n        direction: callback ? 'out' : 'in'\n    };\n    elem[animatingKey] = (cancel) => {\n        clearTimeout(timer);\n        elem.removeEventListener('animationend', handler);\n        elem.removeEventListener('animationcancel', handler);\n        elem.style.animation = prevAnimation;\n        notifyAnimation(elem, 'end', evtPayload);\n        !cancel && finalizeAnimation(callback);\n    };\n    const handler = (evt) => evt.target === elem && stopAnimation(elem);\n    elem.addEventListener('animationend', handler);\n    elem.addEventListener('animationcancel', handler);\n    elem.style.animation = animation;\n    // In case if callback is provided, we have to ensure that animation is actually applied.\n    // In some testing environments, animations could be disabled via\n    // `* { animation: none !important; }`. In this case, we should complete animation ASAP.\n    if (callback) {\n        nextTick(() => {\n            const style = window.getComputedStyle(elem, null);\n            if (!style.animationName || style.animationName === 'none') {\n                stopAnimation(elem);\n            }\n            else {\n                // Handle edge case: animation runs but during animation parent\n                // element is unmounted. In this case `animationend` callback won’t\n                // fire, causing memory leak.\n                // Create timer which will forcibly dispose animation after animation\n                // duration\n                const duration = parseDuration(style.animationDelay) + parseDuration(style.animationDuration);\n                if (duration) {\n                    timer = window.setTimeout(() => stopAnimation(elem), duration);\n                }\n            }\n        });\n    }\n    notifyAnimation(elem, 'start', evtPayload);\n}\n/**\n * Starts JS animation on given element\n */\nfunction tweenAnimate(elem, animation, callback) {\n    // Stop previous animation, if any\n    const prevAnim = findTween(elem);\n    stopAnimation(elem, true);\n    let options = animation(elem);\n    if (options) {\n        options = assign({}, defaultTween, options);\n        if (typeof options.easing !== 'function') {\n            throw new Error('Easing must be a function');\n        }\n        const now = performance.now();\n        const offset = prevAnim\n            ? 1 - (now - prevAnim.start) / (prevAnim.end - prevAnim.start)\n            : 0;\n        const start = now + options.delay - (offset * options.duration);\n        const anim = {\n            elem,\n            options,\n            start,\n            end: start + options.duration,\n            started: false\n        };\n        const evtPayload = {\n            animation,\n            tween: options,\n            direction: callback ? 'out' : 'in'\n        };\n        pool.push(anim);\n        elem[animatingKey] = (cancel) => {\n            pool.splice(pool.indexOf(anim), 1);\n            options.complete && options.complete(elem, options);\n            notifyAnimation(elem, 'end', evtPayload);\n            !cancel && finalizeAnimation(callback);\n        };\n        if (pool.length === 1) {\n            tweenLoop(now);\n        }\n        notifyAnimation(elem, 'start', evtPayload);\n    }\n    else if (callback) {\n        callback();\n    }\n}\n/**\n * Creates animation CSS value with scoped animation name\n */\nfunction createAnimation(animation, cssScope) {\n    if (animation == null) {\n        return '';\n    }\n    const parts = String(animation).split(' ');\n    const name = parts[0].trim();\n    const globalPrefix = 'global:';\n    if (name.indexOf(globalPrefix) === 0) {\n        // Do not scope animation name, use globally defined animation name\n        parts[0] = name.slice(globalPrefix.length);\n    }\n    else if (cssScope) {\n        parts[0] = concat(name, cssScope);\n    }\n    return parts.join(' ').trim();\n}\n/**\n * Composes two tween options objects into single one: instead of simple `assign`,\n * callbacks from both tweens will be composed into a single call\n */\nfunction composeTween(tween1, tween2) {\n    const next = assign({}, tween1, tween2);\n    const callbacks = ['start', 'step', 'complete'];\n    for (let i = 0; i < callbacks.length; i++) {\n        const cbName = callbacks[i];\n        const cb1 = tween1 && tween1[cbName];\n        const cb2 = tween2 && tween2[cbName];\n        if (cb1 && cb2) {\n            next[cbName] = (elem, p1, p2) => {\n                cb1(elem, p1, p2);\n                cb2(elem, p1, p2);\n            };\n        }\n    }\n    return next;\n}\n/**\n * Finalizes current animation: invokes given callback and blocks all nested\n * animations\n */\nfunction finalizeAnimation(callback) {\n    if (callback) {\n        blocked = true;\n        safeCall(callback);\n        blocked = false;\n    }\n}\nfunction tweenLoop(now) {\n    for (let i = pool.length - 1, anim; i >= 0; i--) {\n        anim = pool[i];\n        const { elem, options } = anim;\n        if (now >= anim.start) {\n            if (!anim.started) {\n                anim.started = true;\n                options.start && options.start(elem, options);\n            }\n            const finished = now >= anim.end;\n            const pos = finished ? 1 : options.easing(now - anim.start, 0, 1, options.duration);\n            options.step && options.step(elem, pos, options);\n            if (finished) {\n                stopAnimation(elem);\n            }\n        }\n    }\n    if (pool.length) {\n        requestAnimationFrame(tweenLoop);\n    }\n}\nfunction stopAnimation(elem, cancel) {\n    const callback = elem && elem[animatingKey];\n    if (callback) {\n        elem[animatingKey] = null;\n        callback(cancel);\n    }\n}\n/**\n * Finds existing tween animation for given element, if any\n */\nfunction findTween(elem) {\n    for (let i = 0; i < pool.length; i++) {\n        if (pool[i].elem === elem) {\n            return pool[i];\n        }\n    }\n    return null;\n}\n/**\n * Concatenates two strings with optional separator\n */\nfunction concat(name, suffix) {\n    const sep = suffix[0] === '_' || suffix[0] === '-' ? '' : '-';\n    return name + sep + suffix;\n}\nfunction nextTick(fn) {\n    if (typeof Promise !== 'undefined') {\n        Promise.resolve().then(fn);\n    }\n    else {\n        requestAnimationFrame(fn);\n    }\n}\nfunction notifyAnimation(elem, stage, detail) {\n    try {\n        elem.dispatchEvent(new CustomEvent(`animate-${stage}`, {\n            bubbles: false,\n            cancelable: false,\n            detail\n        }));\n    }\n    catch (err) {\n        // pass\n    }\n}\nfunction parseDuration(value) {\n    if (!value) {\n        return 0;\n    }\n    const ms = value.indexOf('ms') !== -1 ? 1 : 1000;\n    return parseFloat(value) * ms;\n}\n\n/**\n * Creates Endorphin component and mounts it into given `options.target` container\n */\nfunction endorphin(name, definition, options = {}) {\n    const component = createComponent(name, definition, options.target);\n    if (options.store) {\n        component.store = options.store;\n    }\n    if (options.target && !options.detached) {\n        options.target.appendChild(component);\n    }\n    mountComponent(component, options.props);\n    return component;\n}\n/**\n * Safe property getter\n * @param {*} ctx\n * @param {*} ...args\n * @returns {*}\n */\nfunction get(ctx) {\n    const hasMap = typeof Map !== 'undefined';\n    for (let i = 1, il = arguments.length, arg; ctx != null && i < il; i++) {\n        arg = arguments[i];\n        if (hasMap && ctx instanceof Map) {\n            ctx = ctx.get(arg);\n        }\n        else {\n            ctx = ctx[arg];\n        }\n    }\n    return ctx;\n}\n/**\n * Invokes `methodName` of `ctx` object with given args\n */\nfunction call(ctx, methodName, args) {\n    const method = ctx != null && ctx[methodName];\n    if (typeof method === 'function') {\n        return args ? method.apply(ctx, args) : method.call(ctx);\n    }\n}\n/**\n * Filter items from given collection that matches `fn` criteria and returns\n * matched items\n */\nfunction filter(collection, fn) {\n    const result = [];\n    if (collection && collection.forEach) {\n        collection.forEach((value, key) => {\n            if (fn(value, key)) {\n                result.push(value);\n            }\n        });\n    }\n    return result;\n}\n/**\n * Finds first item in given `collection` that matches truth test of `fn`\n */\nfunction find(collection, fn) {\n    if (Array.isArray(collection)) {\n        // Fast path: find item in array\n        for (let i = 0, item; i < collection.length; i++) {\n            item = collection[i];\n            if (fn(item, i)) {\n                return item;\n            }\n        }\n    }\n    else if (collection && collection.forEach) {\n        // Iterate over collection\n        let found = false;\n        let result = null;\n        collection.forEach((value, key) => {\n            if (!found && fn(value, key)) {\n                found = true;\n                result = value;\n            }\n        });\n        return result;\n    }\n}\n\nexport default endorphin;\nexport { Store, addEvent, addPendingClass, addPendingClassIf, animate, appendChild, assign, call, classNames, clearBlock, clearInnerHTML, clearIterator, clearKeyIterator, clearPartial, composeTween, createAnimation, createComponent, createComponentFromElement, createInjector, createScope, createSlot, cssAnimate, detachPendingEvents, disposeBlock, domInsert, domRemove, elem, elemNS, elemNSWithText, elemWithText, emptyBlockContent, enterScope, exitScope, filter, finalizeAttributes, finalizePendingEvents, finalizePendingRefs, find, get, getPartial, getProp, getScope, getSlotContext, getState, getVar, injectBlock, inputValue, insert, isolateElement, mountBlock, mountComponent, mountInnerHTML, mountIterator, mountKeyIterator, mountPartial, mountSlot, move, notifySlotUpdate, obj, pendingEvents, prepareScope, propsSet, removeEvent, removeRef, renderComponent, safeEventListener, scheduleRender, setAttribute, setAttributeExpression, setAttributeExpressionNS, setAttributeNS, setClass, setPendingAttributeNS, setPendingEvent, setPendingRef, setRef, setScope, setVar, stopAnimation, subscribeStore, text, tweenAnimate, unmountBlock, unmountComponent, unmountInnerHTML, unmountIterator, unmountKeyIterator, unmountPartial, unmountSlot, updateAttribute, updateAttributeNS, updateBlock, updateClass, updateComponent, updateDefaultSlot, updateIncomingSlot, updateInnerHTML, updateIterator, updateKeyIterator, updatePartial, updatePendingAttribute, updatePendingAttributeNS, updateProperty, updateText };\n//# sourceMappingURL=runtime.es.js.map\n",null,"<link rel=\"stylesheet\" href=\"./rod-app.scss\" />\n<script src=\"./rod-app.ts\"></script>\n\n<template>\n    Hello world!<br/>\n    <button on:click={onClick}>Click me</button>\n\t<p>Clicked { #count } { #count !== 1 ? 'times' : 'time' }</p>\n</template>",null],"names":["#count"],"mappings":"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"}