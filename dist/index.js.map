{"version":3,"file":"index.js","sources":["../node_modules/endorphin/runtime/runtime.es.js","../src/components/rod-app/rod-app.ts","../src/components/rod-app/rod-app.html","../src/index.ts"],"sourcesContent":["/**\n * Shorthand for `elem.appendChild()` for better minification\n */\nfunction appendChild(element, node) {\n    return element.appendChild(node);\n}\n/**\n * Creates element with given tag name\n * @param cssScope Scope for CSS isolation\n */\nfunction elem(tagName, cssScope) {\n    const el = document.createElement(tagName);\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Creates element with given tag name under `ns` namespace\n * @param cssScope Scope for CSS isolation\n */\nfunction elemNS(tagName, ns, cssScope) {\n    const el = document.createElementNS(ns, tagName);\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Creates element with given tag name and text\n * @param cssScope Scope for CSS isolation\n */\nfunction elemWithText(tagName, value, cssScope) {\n    const el = elem(tagName, cssScope);\n    el.appendChild(textNode(value));\n    return el;\n}\n/**\n * Creates element with given tag name under `ns` namespace and text\n * @param cssScope Scope for CSS isolation\n */\nfunction elemNSWithText(tagName, ns, value, cssScope) {\n    const el = elemNS(tagName, ns, cssScope);\n    el.appendChild(textNode(value));\n    return el;\n}\n/**\n * Creates text node with given value\n */\nfunction text(value) {\n    const node = textNode(value);\n    node.$value = value;\n    return node;\n}\n/**\n * Creates text node with given value\n */\nfunction textNode(value) {\n    return document.createTextNode(value != null ? value : '');\n}\n/**\n * Updates given text node value, if required\n * @returns Returns `1` if text was updated, `0` otherwise\n */\nfunction updateText(node, value) {\n    if (value !== node.$value) {\n        // node.nodeValue = textValue(value);\n        node.nodeValue = value != null ? value : '';\n        node.$value = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Isolates given element with CSS scope\n */\nfunction isolateElement(el, cssScope) {\n    el.setAttribute(cssScope, '');\n    return el;\n}\n/**\n * @returns Inserted item\n */\nfunction domInsert(node, parent, anchor) {\n    return anchor\n        ? parent.insertBefore(node, anchor)\n        : parent.appendChild(node);\n}\n/**\n * Removes given DOM node from its tree\n * @param {Node} node\n */\nfunction domRemove(node) {\n    const { parentNode } = node;\n    parentNode && parentNode.removeChild(node);\n}\n/**\n * Returns textual representation of given `value` object\n */\n// function textValue(value: any): string {\n// \treturn value != null ? value : '';\n// }\n\nconst animatingKey = '$$animating';\n/**\n * Creates fast object\n */\nfunction obj(proto = null) {\n    return Object.create(proto);\n}\n/**\n * Check if given value id defined, e.g. not `null`, `undefined` or `NaN`\n */\nfunction isDefined(value) {\n    return value != null && value === value;\n}\n/**\n * Returns properties from `next` which were changed since `prev` state.\n * Returns `null` if there are no changes\n */\nfunction changed(next, prev, prefix = '') {\n    const result = obj();\n    let dirty = false;\n    // Check if data was actually changed\n    for (const p in next) {\n        if (prev[p] !== next[p]) {\n            dirty = true;\n            result[prefix ? prefix + p : p] = {\n                prev: prev[p],\n                current: next[p]\n            };\n        }\n    }\n    return dirty ? result : null;\n}\n// tslint:disable-next-line:only-arrow-functions\nconst assign = Object.assign || function (target) {\n    for (let i = 1, source; i < arguments.length; i++) {\n        source = arguments[i];\n        for (const p in source) {\n            if (source.hasOwnProperty(p)) {\n                target[p] = source[p];\n            }\n        }\n    }\n    return target;\n};\n/**\n * Returns property descriptors from given object\n */\n// tslint:disable-next-line:only-arrow-functions\nconst getObjectDescriptors = Object['getOwnPropertyDescriptors'] || function (source) {\n    const descriptors = obj();\n    const props = Object.getOwnPropertyNames(source);\n    for (let i = 0, prop, descriptor; i < props.length; i++) {\n        prop = props[i];\n        descriptor = Object.getOwnPropertyDescriptor(source, prop);\n        if (descriptor != null) {\n            descriptors[prop] = descriptor;\n        }\n    }\n    return descriptors;\n};\nfunction safeCall(fn, arg1, arg2) {\n    try {\n        return fn && fn(arg1, arg2);\n    }\n    catch (err) {\n        // tslint:disable-next-line:no-console\n        console.error(err);\n    }\n}\nfunction captureError(host, fn, arg1, arg2) {\n    try {\n        return fn && fn(arg1, arg2);\n    }\n    catch (error) {\n        runtimeError(host, error);\n        // tslint:disable-next-line:no-console\n        console.error(error);\n    }\n}\nfunction runtimeError(host, error) {\n    if (typeof CustomEvent !== 'undefined') {\n        host.dispatchEvent(new CustomEvent('runtime-error', {\n            bubbles: true,\n            cancelable: true,\n            detail: { error, host }\n        }));\n    }\n    else {\n        throw error;\n    }\n}\n\n/**\n * Registers given event listener on `target` element and returns event binding\n * object to unregister event\n */\nfunction addEvent(target, type, listener, host, scope) {\n    return registerBinding(type, { host, scope, target, listener, handleEvent });\n}\n/**\n * Unregister given event binding\n */\nfunction removeEvent(type, binding) {\n    binding.target.removeEventListener(type, binding);\n}\n/**\n * Creates structure for collecting pending events\n */\nfunction pendingEvents(host, target) {\n    return { host, target, events: obj() };\n}\nfunction setPendingEvent(pending, type, listener, scope) {\n    let binding = pending.events[type];\n    if (binding) {\n        binding.listener = listener;\n        binding.scope = scope;\n    }\n    else {\n        binding = pending.events[type] = addEvent(pending.target, type, listener, pending.host, scope);\n    }\n    binding.pending = listener;\n}\nfunction finalizePendingEvents(pending) {\n    // For event listeners, we should only bind or unbind events, depending\n    // on current listener value\n    const { events } = pending;\n    for (const type in events) {\n        const binding = events[type];\n        if (binding) {\n            if (!binding.pending) {\n                events[type] = removeEvent(type, binding);\n            }\n            binding.pending = void 0;\n        }\n    }\n}\nfunction detachPendingEvents(pending) {\n    const { events } = pending;\n    for (const type in events) {\n        const binding = events[type];\n        if (binding) {\n            removeEvent(type, binding);\n        }\n    }\n}\nfunction handleEvent(event) {\n    try {\n        this.listener && this.listener(this.host, event, this.target, this.scope);\n    }\n    catch (error) {\n        runtimeError(this.host, error);\n        // tslint:disable-next-line:no-console\n        console.error(error);\n    }\n}\nfunction safeEventListener(host, handler) {\n    // tslint:disable-next-line:only-arrow-functions\n    return function (event) {\n        try {\n            handler.call(this, event);\n        }\n        catch (error) {\n            runtimeError(host, error);\n            // tslint:disable-next-line:no-console\n            console.error(error);\n        }\n    };\n}\nfunction registerBinding(type, binding) {\n    binding.target.addEventListener(type, binding);\n    return binding;\n}\n\n/** Base object to create pending namespaced attribute set */\nconst nsProto = obj();\n/**\n * Create pending props change set\n */\nfunction propsSet(elem, initial) {\n    const base = obj(elem.componentModel.defaultProps);\n    return initial ? assign(base, initial) : base;\n}\n/**\n * Alias for `elem.setAttribute`\n */\nfunction setAttribute(elem, name, value) {\n    elem.setAttribute(name, value);\n    return value;\n}\n/**\n * Updates element’s `name` attribute value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateAttribute(elem, prev, name, value) {\n    if (value !== prev[name]) {\n        const primitive = representedValue(value);\n        if (primitive === null) {\n            elem.removeAttribute(name);\n        }\n        else {\n            setAttribute(elem, name, primitive);\n        }\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Alias for `elem.className`\n */\nfunction setClass(elem, value) {\n    elem.className = value;\n    return value;\n}\n/**\n * Shorthand to update class name, specific to Endorphin compiled code\n */\nfunction updateClass(elem, prev, value) {\n    return updateAttribute(elem, prev, 'class', value === '' ? undefined : value);\n}\n/**\n * Sets attribute value as expression. Unlike regular primitive attributes,\n * expression values must be represented, e.g. non-primitive values must be\n * converted to string representations. Also, expression resolved to `false`,\n * `null` or `undefined` will remove attribute from element\n */\nfunction setAttributeExpression(elem, name, value) {\n    const primitive = representedValue(value);\n    primitive === null\n        ? elem.removeAttribute(name)\n        : setAttribute(elem, name, primitive);\n    return value;\n}\n/**\n * Alias for `elem.setAttributeNS`\n */\nfunction setAttributeNS(elem, ns, name, value) {\n    elem.setAttributeNS(ns, name, value);\n    return value;\n}\n/**\n * Updates element’s `name` attribute value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateAttributeNS(elem, prevNS, ns, name, value) {\n    const prev = ns in prevNS ? prevNS[ns] : (prevNS[ns] = obj());\n    if (value !== prev[name]) {\n        const primitive = representedValue(value);\n        if (primitive === null) {\n            elem.removeAttributeNS(ns, name);\n        }\n        else {\n            setAttributeNS(elem, ns, name, primitive);\n        }\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Same as `setAttributeExpression()` but for namespaced attributes\n */\nfunction setAttributeExpressionNS(elem, ns, name, value) {\n    const primitive = representedValue(value);\n    primitive === null\n        ? elem.removeAttributeNS(ns, name)\n        : setAttributeNS(elem, ns, name, primitive);\n    return value;\n}\n/**\n * Sets pending namespaced attribute value which will be added to element later\n */\nfunction setPendingAttributeNS(attrs, ns, name, value) {\n    const map = pendingNS(attrs, ns);\n    map[name] = value;\n}\n/**\n * Updates pending `name` value only if given `value` is not null\n */\nfunction updatePendingAttribute(attrs, name, value) {\n    if (value != null) {\n        attrs[name] = value;\n    }\n}\n/**\n * Updates pending namespaced `name` value only if given `value` is not null\n */\nfunction updatePendingAttributeNS(attrs, ns, name, value) {\n    if (value != null) {\n        pendingNS(attrs, ns)[name] = value;\n    }\n}\n/**\n * Adds given class name to pending attribute set\n */\nfunction addPendingClass(data, className) {\n    if (className != null) {\n        const prev = data.class;\n        data.class = prev ? prev + ' ' + className : String(className);\n    }\n}\n/**\n * Adds given class name to pending attribute set if condition is truthy\n */\nfunction addPendingClassIf(data, className, condition) {\n    condition && addPendingClass(data, className);\n}\n/**\n * Finalizes pending attributes\n */\nfunction finalizeAttributes(elem, cur, prev) {\n    let updated = 0;\n    for (const key in cur) {\n        const curValue = cur[key];\n        if (isPendingNS(curValue)) {\n            // It’s a pending attribute set\n            const prevNS = pendingNS(prev, key);\n            for (const name in curValue) {\n                const curNS = curValue[name];\n                if (curNS !== prevNS[name]) {\n                    updated = 1;\n                    setAttributeExpressionNS(elem, key, name, curNS);\n                    prevNS[name] = curNS;\n                }\n                curValue[name] = null;\n            }\n        }\n        else {\n            if (curValue !== prev[key]) {\n                updated = 1;\n                if (key === 'class') {\n                    elem.className = classNames(curValue);\n                }\n                else {\n                    setAttributeExpression(elem, key, curValue);\n                }\n                prev[key] = curValue;\n            }\n            cur[key] = null;\n        }\n    }\n    return updated;\n}\n/**\n * Returns normalized list of class names from given string\n */\nfunction classNames(str) {\n    if (isDefined(str)) {\n        return String(str).split(/\\s+/).filter(uniqueClassFilter).join(' ');\n    }\n    return '';\n}\n/**\n * Returns value for <input> element\n */\nfunction inputValue(value) {\n    return value != null ? value : '';\n}\n/**\n * Updates element’s `name` property value only if it differs from previous value,\n * defined in `prev`\n */\nfunction updateProperty(elem, prev, name, value) {\n    if (value !== prev[name]) {\n        elem[name] = name === 'value' ? inputValue(value) : value;\n        prev[name] = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Returns represented attribute value for given data\n */\nfunction representedValue(value) {\n    if (value === false || !isDefined(value)) {\n        return null;\n    }\n    if (value === true) {\n        return '';\n    }\n    if (Array.isArray(value)) {\n        return '[]';\n    }\n    if (typeof value === 'function') {\n        return '𝑓';\n    }\n    if (typeof value === 'object') {\n        return '{}';\n    }\n    return value;\n}\n/**\n * Check if given object is a pending namespaced attribute set\n */\nfunction isPendingNS(data) {\n    return data != null && typeof data === 'object' && Object.getPrototypeOf(data) === nsProto;\n}\n/**\n * Ensures given attribute value map contains namespace map for given `ns` and\n * returns it\n */\nfunction pendingNS(attrs, ns) {\n    return ns in attrs ? attrs[ns] : (attrs[ns] = Object.create(nsProto));\n}\nfunction uniqueClassFilter(cl, index, arr) {\n    return cl ? arr.indexOf(cl) === index : false;\n}\n\n/**\n * Creates linted list\n */\n/**\n * Creates linked list item\n */\nfunction createListItem(value) {\n    return { value, next: null, prev: null };\n}\n/**\n * Prepends given value to linked list\n */\nfunction listPrependValue(list, value) {\n    const item = createListItem(value);\n    if (item.next = list.head) {\n        item.next.prev = item;\n    }\n    return list.head = item;\n}\n/**\n * Inserts given value after given `ref` item\n */\nfunction listInsertValueAfter(value, ref) {\n    const item = createListItem(value);\n    const { next } = ref;\n    ref.next = item;\n    item.prev = ref;\n    if (item.next = next) {\n        next.prev = item;\n    }\n    return item;\n}\n/**\n * Moves list fragment with `start` and `end` bounds right after `ref` item\n */\nfunction listMoveFragmentAfter(list, start, end, ref) {\n    listDetachFragment(list, start, end);\n    if (end.next = ref.next) {\n        end.next.prev = end;\n    }\n    ref.next = start;\n    start.prev = ref;\n}\n/**\n * Moves list fragment with `start` and `end` to list head\n */\nfunction listMoveFragmentFirst(list, start, end) {\n    listDetachFragment(list, start, end);\n    if (end.next = list.head) {\n        end.next.prev = end;\n    }\n    list.head = start;\n}\n/**\n * Detaches list fragment with `start` and `end` from list\n */\nfunction listDetachFragment(list, start, end) {\n    const { prev } = start;\n    const { next } = end;\n    if (prev) {\n        prev.next = next;\n    }\n    else {\n        list.head = next;\n    }\n    if (next) {\n        next.prev = prev;\n    }\n    start.prev = end.next = null;\n}\n\n/**\n * Creates injector instance for given target, if required\n */\nfunction createInjector(target) {\n    return {\n        parentNode: target,\n        head: null,\n        ptr: null,\n        // NB create `slots` placeholder to promote object to hidden class.\n        // Do not use any additional function argument for adding value to `slots`\n        // to reduce runtime checks and keep functions in monomorphic state\n        slots: null\n    };\n}\n/**\n * Inserts given node into current context\n */\nfunction insert(injector, node, slotName = '') {\n    const { slots, ptr } = injector;\n    const target = slots\n        ? getSlotContext(injector, slotName).element\n        : injector.parentNode;\n    domInsert(node, target, ptr ? getAnchorNode(ptr.next, target) : void 0);\n    injector.ptr = ptr ? listInsertValueAfter(node, ptr) : listPrependValue(injector, node);\n    return node;\n}\n/**\n * Injects given block\n */\nfunction injectBlock(injector, block) {\n    const { ptr } = injector;\n    if (ptr) {\n        block.end = listInsertValueAfter(block, ptr);\n        block.start = listInsertValueAfter(block, ptr);\n    }\n    else {\n        block.end = listPrependValue(injector, block);\n        block.start = listPrependValue(injector, block);\n    }\n    injector.ptr = block.end;\n    return block;\n}\n/**\n * Returns named slot context from given component input’s injector. If slot context\n * doesn’t exists, it will be created\n */\nfunction getSlotContext(injector, name) {\n    const slots = injector.slots;\n    return slots[name] || (slots[name] = createSlotContext(name));\n}\n/**\n * Empties content of given block\n * @param detached Empty block in detached state. Detached state means one of the\n * parent DOM element will be removed from document so there’s no need to detach\n * inner DOM elements\n */\nfunction emptyBlockContent(block, detached) {\n    const unmount = block.mount && block.mount.dispose;\n    if (unmount) {\n        unmount(block.scope, block.host);\n    }\n    let item = block.start.next;\n    while (item && item !== block.end) {\n        // tslint:disable-next-line:prefer-const\n        let { value, next, prev } = item;\n        if (!isElement(value)) {\n            next = value.end.next;\n            disposeBlock(value);\n        }\n        else if (!detached && !value[animatingKey]) {\n            domRemove(value);\n        }\n        // NB: Block always contains `.next` and `.prev` items which are block\n        // bounds so we can safely skip null check here\n        prev.next = next;\n        next.prev = prev;\n        item = next;\n    }\n}\n/**\n * Moves contents of `block` after `ref` list item\n */\nfunction move(injector, block, ref) {\n    if (ref && ref.next && ref.next.value === block) {\n        return;\n    }\n    // Update linked list\n    const { start, end } = block;\n    if (ref) {\n        listMoveFragmentAfter(injector, start, end, ref);\n    }\n    else {\n        listMoveFragmentFirst(injector, start, end);\n    }\n    // Move block contents in DOM\n    let item = start.next;\n    let node;\n    while (item && item !== end) {\n        if (isElement(item.value)) {\n            node = item.value;\n            // NB it’s possible that a single block contains nodes from different\n            // slots so we have to find anchor for each node individually\n            domInsert(node, node.parentNode, getAnchorNode(end.next, node.parentNode));\n        }\n        item = item.next;\n    }\n}\n/**\n * Disposes given block\n */\nfunction disposeBlock(block, detached) {\n    emptyBlockContent(block, detached);\n    listDetachFragment(block.injector, block.start, block.end);\n    // @ts-ignore: Nulling disposed object\n    block.start = block.end = block.scope = null;\n}\nfunction isElement(obj) {\n    return 'nodeType' in obj;\n}\n/**\n * Get DOM node nearest to given position of items list\n */\nfunction getAnchorNode(item, parent) {\n    while (item) {\n        if (item.value.parentNode === parent) {\n            return item.value;\n        }\n        item = item.next;\n    }\n}\n/**\n * Creates context for given slot\n */\nfunction createSlotContext(name) {\n    const element = document.createElement('slot');\n    name && element.setAttribute('name', name);\n    return {\n        name,\n        element,\n        isDefault: false,\n        defaultContent: null\n    };\n}\n\n/**\n * Invokes `name` hook for given component definition\n */\nfunction runHook(component, name, arg1, arg2) {\n    const { plugins } = component.componentModel;\n    for (let i = plugins.length - 1, hook; i >= 0; i--) {\n        hook = plugins[i][name];\n        if (typeof hook === 'function') {\n            try {\n                hook(component, arg1, arg2);\n            }\n            catch (error) {\n                runtimeError(component, error);\n                // tslint:disable-next-line:no-console\n                console.error(error);\n            }\n        }\n    }\n}\n\n/**\n * Enters new variable scope context\n */\nfunction enterScope(host, incoming) {\n    return setScope(host, createScope(host, incoming));\n}\n/**\n * Exit from current variable scope\n */\nfunction exitScope(host) {\n    return setScope(host, Object.getPrototypeOf(host.componentModel.vars));\n}\n/**\n * Creates new scope from given component state\n */\nfunction createScope(host, incoming) {\n    return assign(obj(host.componentModel.vars), incoming);\n}\n/**\n * Sets given object as current component scope\n */\nfunction setScope(host, scope) {\n    return host.componentModel.vars = scope;\n}\n/**\n * Returns current variable scope\n */\nfunction getScope(elem) {\n    return elem.componentModel.vars;\n}\n/**\n * Returns property with given name from component\n */\nfunction getProp(elem, name) {\n    return elem.props[name];\n}\n/**\n * Returns state value with given name from component\n */\nfunction getState(elem, name) {\n    return elem.state[name];\n}\n/**\n * Returns value of given runtime variable from component\n */\nfunction getVar(elem, name) {\n    return elem.componentModel.vars[name];\n}\n/**\n * Sets value of given runtime variable for component\n */\nfunction setVar(elem, name, value) {\n    elem.componentModel.vars[name] = value;\n}\n\n/**\n * Creates slot element\n */\nfunction createSlot(host, name, cssScope) {\n    const el = getSlotContext(host.componentModel.input, name).element;\n    return cssScope ? isolateElement(el, cssScope) : el;\n}\n/**\n * Mounts slot context\n */\nfunction mountSlot(host, name, defaultContent) {\n    const { input } = host.componentModel;\n    const ctx = getSlotContext(input, name);\n    const injector = createInjector(ctx.element);\n    if (defaultContent) {\n        // Add block with default slot content\n        ctx.defaultContent = injectBlock(injector, {\n            host,\n            injector,\n            scope: getScope(host),\n            content: defaultContent,\n            mount: void 0,\n            update: void 0\n        });\n    }\n    if (isEmpty(ctx)) {\n        // No incoming content, mount default content\n        renderDefaultContent(ctx);\n    }\n    else {\n        setSlotted(ctx, true);\n    }\n    return ctx;\n}\n/**\n * Handles possible update of incoming data\n */\nfunction updateIncomingSlot(host, name, updated) {\n    const ctx = getSlotContext(host.componentModel.input, name);\n    if (updated) {\n        // Incoming content was updated but there’s default content mounted\n        if (ctx.isDefault) {\n            const block = ctx.defaultContent;\n            if (block) {\n                emptyBlockContent(block);\n                block.mount = void 0;\n            }\n            setSlotted(ctx, true);\n        }\n        notifySlotUpdate(host, ctx);\n    }\n    if (!ctx.isDefault && isEmpty(ctx)) {\n        // If slot content is empty, ensure default content is rendered\n        renderDefaultContent(ctx);\n    }\n}\n/**\n * Updates default slot content only if it was already rendered\n */\nfunction updateDefaultSlot(ctx) {\n    if (ctx.isDefault) {\n        const block = ctx.defaultContent;\n        if (block.update) {\n            block.update(block.host, block.scope);\n        }\n    }\n}\n/**\n * Unmounts default content of given slot context\n */\nfunction unmountSlot(ctx) {\n    const block = ctx.defaultContent;\n    if (block) {\n        disposeBlock(block);\n        setSlotted(ctx, false);\n        ctx.isDefault = false;\n        ctx.defaultContent = null;\n    }\n}\nfunction notifySlotUpdate(host, ctx) {\n    runHook(host, 'didSlotUpdate', ctx.name, ctx.element);\n}\n/**\n * Renders default slot content\n */\nfunction renderDefaultContent(ctx) {\n    if (ctx.defaultContent) {\n        const block = ctx.defaultContent;\n        const { injector } = block;\n        injector.ptr = block.start;\n        block.mount = block.content;\n        block.update = block.mount(block.host, injector, block.scope);\n        injector.ptr = block.end;\n    }\n    setSlotted(ctx, false);\n}\n/**\n * Check if given slot is empty\n */\nfunction isEmpty(ctx) {\n    // TODO better check for input content?\n    return !ctx.element.childNodes.length;\n}\n/**\n * Toggles slotted state in slot container\n */\nfunction setSlotted(ctx, slotted) {\n    ctx.isDefault = !slotted;\n    slotted ? ctx.element.setAttribute('slotted', '') : ctx.element.removeAttribute('slotted');\n}\n\nlet renderQueue = null;\n/** A lookup of normalized attributes */\nconst attributeLookup = {};\n/**\n * Creates Endorphin DOM component with given definition\n */\nfunction createComponent(name, definition, host) {\n    let cssScope;\n    let root;\n    if (host && 'componentModel' in host) {\n        cssScope = host.componentModel.definition.cssScope;\n        root = host.root || host;\n    }\n    const element = elem(name, cssScope);\n    return createComponentFromElement(element, definition, root);\n}\n/**\n * Convert HTMLElement into Endorphin DOM component with given definition\n */\nfunction createComponentFromElement(el, definition, root) {\n    const element = el;\n    // Add host scope marker: we can’t rely on tag name since component\n    // definition is bound to element in runtime, not compile time\n    if (definition.cssScope) {\n        element.setAttribute(definition.cssScope + '-host', '');\n    }\n    const { props, state, extend, events, plugins } = prepare(element, definition);\n    element.refs = obj();\n    element.props = obj();\n    element.state = state;\n    element.componentView = element; // XXX Should point to Shadow Root in Web Components\n    root && (element.root = root);\n    addPropsState(element);\n    if (extend) {\n        Object.defineProperties(element, extend);\n    }\n    if (definition.store) {\n        element.store = definition.store();\n    }\n    else if (root && root.store) {\n        element.store = root.store;\n    }\n    // Create slotted input\n    const input = createInjector(element.componentView);\n    input.slots = obj();\n    element.componentModel = {\n        definition,\n        input,\n        vars: obj(),\n        mounted: false,\n        preparing: false,\n        update: void 0,\n        queued: false,\n        events,\n        plugins,\n        partialDeps: null,\n        defaultProps: props\n    };\n    runHook(element, 'init');\n    return element;\n}\n/**\n * Mounts given component\n */\nfunction mountComponent(component, props) {\n    const { componentModel } = component;\n    const { input, definition } = componentModel;\n    const changes = setPropsInternal(component, props || componentModel.defaultProps);\n    const arg = changes || {};\n    componentModel.preparing = true;\n    // Notify slot status\n    for (const p in input.slots) {\n        notifySlotUpdate(component, input.slots[p]);\n    }\n    if (changes) {\n        runHook(component, 'didChange', arg);\n    }\n    runHook(component, 'willMount', arg);\n    runHook(component, 'willRender', arg);\n    componentModel.preparing = false;\n    componentModel.update = captureError(component, definition.default, component, getScope(component));\n    componentModel.mounted = true;\n    runHook(component, 'didRender', arg);\n    runHook(component, 'didMount', arg);\n}\n/**\n * Updates given mounted component\n */\nfunction updateComponent(component, props, partialDeps) {\n    const { componentModel } = component;\n    let changes = props && setPropsInternal(component, props);\n    if (partialDeps) {\n        if (!changes && partialDepsUpdated(componentModel.partialDeps, partialDeps)) {\n            changes = obj();\n        }\n        componentModel.partialDeps = partialDeps;\n    }\n    if (changes || componentModel.queued) {\n        renderNext(component, changes);\n    }\n    return changes ? 1 : 0;\n}\n/**\n * Destroys given component: removes static event listeners and cleans things up\n * @returns Should return nothing since function result will be used\n * as shorthand to reset cached value\n */\nfunction unmountComponent(component) {\n    const { componentModel } = component;\n    const { definition, events } = componentModel;\n    runHook(component, 'willUnmount');\n    componentModel.mounted = false;\n    if (events) {\n        detachStaticEvents(component, events);\n    }\n    if (component.store) {\n        component.store.unwatch(component);\n    }\n    const dispose = definition.default && definition.default.dispose;\n    captureError(component, dispose, getScope(component));\n    runHook(component, 'didUnmount');\n    // @ts-ignore: Nulling disposed object\n    component.componentModel = null;\n}\n/**\n * Subscribes to store updates of given component\n */\nfunction subscribeStore(component, keys) {\n    if (!component.store) {\n        throw new Error(`Store is not defined for ${component.nodeName} component`);\n    }\n    component.store.watch(component, keys);\n}\n/**\n * Queues next component render\n */\nfunction renderNext(component, changes) {\n    if (!component.componentModel.preparing) {\n        renderComponent(component, changes);\n    }\n    else {\n        scheduleRender(component, changes);\n    }\n}\n/**\n * Schedules render of given component on next tick\n */\nfunction scheduleRender(component, changes) {\n    if (!component.componentModel.queued) {\n        component.componentModel.queued = true;\n        if (renderQueue) {\n            renderQueue.push(component, changes);\n        }\n        else {\n            renderQueue = [component, changes];\n            requestAnimationFrame(drainQueue);\n        }\n    }\n}\n/**\n * Renders given component\n */\nfunction renderComponent(component, changes) {\n    const { componentModel } = component;\n    const arg = changes || {};\n    componentModel.queued = false;\n    componentModel.preparing = true;\n    if (changes) {\n        runHook(component, 'didChange', arg);\n    }\n    runHook(component, 'willUpdate', arg);\n    runHook(component, 'willRender', arg);\n    componentModel.preparing = false;\n    captureError(component, componentModel.update, component, getScope(component));\n    runHook(component, 'didRender', arg);\n    runHook(component, 'didUpdate', arg);\n}\n/**\n * Removes attached events from given map\n */\nfunction detachStaticEvents(component, eventMap) {\n    const { listeners, handler } = eventMap;\n    for (const p in listeners) {\n        component.removeEventListener(p, handler);\n    }\n}\nfunction kebabCase(ch) {\n    return '-' + ch.toLowerCase();\n}\nfunction setPropsInternal(component, nextProps) {\n    let changes;\n    const { props } = component;\n    const { defaultProps } = component.componentModel;\n    let prev;\n    let current;\n    for (const p in nextProps) {\n        prev = props[p];\n        current = nextProps[p];\n        if (current == null && p in defaultProps) {\n            current = defaultProps[p];\n        }\n        if (p === 'class' && current != null) {\n            current = classNames(current);\n        }\n        if (current !== prev) {\n            if (!changes) {\n                changes = obj();\n            }\n            props[p] = current;\n            changes[p] = { current, prev };\n            if (!/^partial:/.test(p)) {\n                setAttributeExpression(component, normalizeAttribute(p), current);\n            }\n        }\n    }\n    return changes;\n}\n/**\n * Check if `next` contains value that differs from one in `prev`\n */\nfunction hasChanges(prev, next) {\n    for (const p in next) {\n        if (next[p] !== prev[p]) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Prepares internal data for given component\n */\nfunction prepare(component, definition) {\n    const props = obj();\n    const state = obj();\n    const plugins = collectPlugins(component, definition, [definition]);\n    let events;\n    let extend;\n    for (let i = plugins.length - 1; i >= 0; i--) {\n        const dfn = plugins[i];\n        dfn.props && assign(props, dfn.props(component));\n        dfn.state && assign(state, dfn.state(component));\n        // NB: backward compatibility with previous implementation\n        if (dfn.methods) {\n            extend = getDescriptors(dfn.methods, extend);\n        }\n        if (dfn.extend) {\n            extend = getDescriptors(dfn.extend, extend);\n        }\n        if (dfn.events) {\n            if (!events) {\n                events = createEventsMap(component);\n            }\n            attachEventHandlers(component, dfn.events, events);\n        }\n    }\n    return { props, state, extend, events, plugins };\n}\n/**\n * Collects all plugins (including nested) into a flat list\n */\nfunction collectPlugins(component, definition, dest = []) {\n    let { plugins } = definition;\n    if (typeof plugins === 'function') {\n        plugins = plugins(component);\n    }\n    if (Array.isArray(plugins)) {\n        for (let i = 0; i < plugins.length; i++) {\n            dest.push(plugins[i]);\n            collectPlugins(component, plugins[i], dest);\n        }\n    }\n    return dest;\n}\n/**\n * Extracts property descriptors from given source object and merges it with `prev`\n * descriptor map, if given\n */\nfunction getDescriptors(source, prev) {\n    const descriptors = getObjectDescriptors(source);\n    return prev ? assign(prev, descriptors) : descriptors;\n}\nfunction createEventsMap(component) {\n    const listeners = obj();\n    const handler = function (evt) {\n        if (component.componentModel) {\n            const handlers = listeners[evt.type];\n            for (let i = 0; i < handlers.length; i++) {\n                handlers[i](component, evt, this);\n            }\n        }\n    };\n    return { handler: safeEventListener(component, handler), listeners };\n}\nfunction attachEventHandlers(component, events, eventMap) {\n    const names = Object.keys(events);\n    const { listeners } = eventMap;\n    for (let i = 0, name; i < names.length; i++) {\n        name = names[i];\n        if (name in listeners) {\n            listeners[name].push(events[name]);\n        }\n        else {\n            component.addEventListener(name, eventMap.handler);\n            listeners[name] = [events[name]];\n        }\n    }\n}\nfunction addPropsState(element) {\n    element.setProps = function setProps(value) {\n        const { componentModel } = element;\n        // In case of calling `setProps` after component was unmounted,\n        // check if `componentModel` is available\n        if (value != null && componentModel && componentModel.mounted) {\n            const changes = setPropsInternal(element, assign(obj(), value));\n            changes && renderNext(element, changes);\n            return changes;\n        }\n    };\n    element.setState = function setState(value) {\n        const { componentModel } = element;\n        // In case of calling `setState` after component was unmounted,\n        // check if `componentModel` is available\n        if (value != null && componentModel && hasChanges(element.state, value)) {\n            assign(element.state, value);\n            // If we’re in rendering state than current `setState()` is caused by\n            // one of the `will*` hooks, which means applied changes will be automatically\n            // applied during rendering stage.\n            // If called outside of rendering state we should schedule render\n            // on next tick\n            if (componentModel.mounted && !componentModel.preparing) {\n                scheduleRender(element);\n            }\n        }\n    };\n}\nfunction drainQueue() {\n    const pending = renderQueue;\n    renderQueue = null;\n    for (let i = 0, component; i < pending.length; i += 2) {\n        component = pending[i];\n        // It’s possible that a component can be rendered before next tick\n        // (for example, if parent node updated component props).\n        // Check if it’s still queued then render.\n        // Also, component can be unmounted after it’s rendering was scheduled\n        if (component.componentModel && component.componentModel.queued) {\n            renderComponent(component, pending[i + 1]);\n        }\n    }\n}\n/**\n * Normalizes given attribute name: converts `camelCase` to `kebab-case`\n */\nfunction normalizeAttribute(attr) {\n    if (!(attr in attributeLookup)) {\n        attributeLookup[attr] = attr.replace(/[A-Z]/g, kebabCase);\n    }\n    return attributeLookup[attr];\n}\n/**\n * Check if partial dependencies of component were updated\n */\nfunction partialDepsUpdated(prev, next) {\n    if (!prev) {\n        return true;\n    }\n    // In compiler, deps will always have the same length\n    for (let i = 0; i < prev.length; i++) {\n        if (prev[i] !== next[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction mountBlock(host, injector, get) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        mount: undefined,\n        update: undefined\n    });\n    updateBlock(block);\n    return block;\n}\n/**\n * Updated block, described in `ctx` object\n * @returns Returns `1` if block was updated, `0` otherwise\n */\nfunction updateBlock(block) {\n    let updated = 0;\n    const { host, injector, scope } = block;\n    const mount = block.get(host, scope);\n    if (block.mount !== mount) {\n        updated = 1;\n        // Unmount previously rendered content\n        block.mount && emptyBlockContent(block);\n        // Mount new block content\n        injector.ptr = block.start;\n        block.mount = mount;\n        block.update = mount && mount(block.host, injector, scope);\n    }\n    else if (block.update) {\n        // Update rendered result\n        updated = block.update(host, scope) ? 1 : 0;\n    }\n    block.injector.ptr = block.end;\n    return updated;\n}\nfunction unmountBlock(block) {\n    disposeBlock(block);\n}\nfunction clearBlock(block) {\n    disposeBlock(block, true);\n}\n\n/**\n * Mounts iterator block\n * @param get A function that returns collection to iterate\n * @param body A function that renders item of iterated collection\n */\nfunction mountIterator(host, injector, get, body) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        body,\n        index: 0,\n        updated: 0\n    });\n    updateIterator(block);\n    return block;\n}\n/**\n * Updates iterator block defined in `ctx`\n * @returns Returns `1` if iterator was updated, `0` otherwise\n */\nfunction updateIterator(block) {\n    const { injector } = block;\n    injector.ptr = block.start;\n    block.index = block.updated = 0;\n    const collection = block.get(block.host, block.scope);\n    if (collection && typeof collection.forEach === 'function') {\n        collection.forEach(iterator, block);\n    }\n    trimIteratorItems(block, injector.ptr.next);\n    injector.ptr = block.end;\n    return block.updated;\n}\nfunction unmountIterator(block) {\n    disposeBlock(block);\n}\nfunction clearIterator(block) {\n    disposeBlock(block, true);\n}\nfunction prepareScope(scope, index, key, value) {\n    scope.index = index;\n    scope.key = key;\n    scope.value = value;\n    return scope;\n}\n/**\n * Removes remaining iterator items from current context\n */\nfunction trimIteratorItems(block, start) {\n    let listItem;\n    while (start !== block.end) {\n        block.updated = 1;\n        listItem = start.value;\n        start = listItem.end.next;\n        disposeBlock(listItem);\n    }\n}\nfunction iterator(value, key) {\n    const { host, injector, index, body, end } = this;\n    const { next } = injector.ptr;\n    const prevScope = getScope(host);\n    let rendered;\n    if (next !== end) {\n        rendered = next.value;\n        // We have rendered item, update it\n        if (rendered.update) {\n            const scope = prepareScope(rendered.scope, index, key, value);\n            setScope(host, scope);\n            if (rendered.update(host, scope)) {\n                this.updated = 1;\n            }\n            setScope(host, prevScope);\n        }\n    }\n    else {\n        // Create & render new block\n        const scope = prepareScope(obj(prevScope), index, key, value);\n        rendered = injectBlock(injector, {\n            host,\n            injector,\n            scope,\n            mount: body,\n            update: undefined,\n        });\n        setScope(host, scope);\n        injector.ptr = rendered.start;\n        rendered.update = body(host, injector, scope);\n        setScope(host, prevScope);\n        this.updated = 1;\n    }\n    injector.ptr = rendered.end;\n    this.index++;\n}\n\n/**\n * Renders key iterator block\n */\nfunction mountKeyIterator(host, injector, get, keyExpr, body) {\n    const parentScope = getScope(host);\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: obj(parentScope),\n        get,\n        body,\n        keyExpr,\n        index: 0,\n        updated: 0,\n        used: null,\n        rendered: null,\n        needReorder: false,\n        parentScope,\n        order: []\n    });\n    updateKeyIterator(block);\n    return block;\n}\n/**\n * Updates iterator block defined in `ctx`\n * @returns Returns `1` if iterator was updated, `0` otherwise\n */\nfunction updateKeyIterator(block) {\n    const { host, injector, rendered } = block;\n    injector.ptr = block.start;\n    block.used = obj();\n    block.index = block.updated = 0;\n    block.needReorder = false;\n    const collection = block.get(host, block.parentScope);\n    if (collection && typeof collection.forEach === 'function') {\n        const prevScope = getScope(host);\n        collection.forEach(keyIterator, block);\n        setScope(host, prevScope);\n    }\n    if (rendered) {\n        block.updated |= disposeLookup(rendered);\n    }\n    if (block.needReorder) {\n        block.updated = 1;\n        reorder(block);\n    }\n    block.order.length = 0;\n    block.rendered = block.used;\n    injector.ptr = block.end;\n    return block.updated;\n}\nfunction unmountKeyIterator(block) {\n    disposeBlock(block);\n}\nfunction clearKeyIterator(block) {\n    disposeBlock(block, true);\n}\nfunction getItem(listItem, bound) {\n    return listItem !== bound ? listItem.value : null;\n}\nfunction keyIterator(value, key) {\n    const { injector, index, rendered } = this;\n    const id = this.keyExpr(value, prepareScope(this.scope, index, key, value));\n    let entry = rendered && getLookup(rendered, id);\n    if (entry) {\n        if (entry.start.prev !== injector.ptr) {\n            this.needReorder = true;\n        }\n        this.updated |= updateEntry(entry, value, key, index);\n    }\n    else {\n        entry = mountEntry(this, value, key, index);\n        this.updated = 1;\n    }\n    putLookup(this.used, id, entry);\n    this.order.push(entry);\n    injector.ptr = entry.end;\n    this.index++;\n}\nfunction mountEntry(block, value, key, index) {\n    const { host, injector, body: mount } = block;\n    const scope = prepareScope(obj(block.scope), index, key, value);\n    setScope(host, scope);\n    const entry = injectBlock(injector, {\n        host,\n        injector,\n        scope,\n        mount,\n        update: undefined,\n        next: null\n    });\n    injector.ptr = entry.start;\n    entry.update = mount && mount(host, injector, scope);\n    return entry;\n}\nfunction updateEntry(entry, value, key, index) {\n    if (entry.update) {\n        const { host } = entry;\n        const scope = prepareScope(entry.scope, index, key, value);\n        setScope(host, scope);\n        if (entry.update(host, scope)) {\n            return 1;\n        }\n    }\n    return 0;\n}\nfunction reorder(block) {\n    const { injector, order } = block;\n    let actualPrev;\n    let actualNext;\n    let expectedPrev;\n    let expectedNext;\n    const { start, end } = block;\n    for (let i = 0, maxIx = order.length - 1, item; i <= maxIx; i++) {\n        item = order[i];\n        expectedPrev = i > 0 ? order[i - 1] : null;\n        expectedNext = i < maxIx ? order[i + 1] : null;\n        actualPrev = getItem(item.start.prev, start);\n        actualNext = getItem(item.end.next, end);\n        if (expectedPrev !== actualPrev || expectedNext !== actualNext) {\n            // Blocks must be reordered\n            move(injector, item, expectedPrev ? expectedPrev.end : block.start);\n        }\n    }\n}\nfunction getLookup(lookup, key) {\n    const item = lookup[key];\n    if (item && (lookup[key] = item.next)) {\n        item.next = null;\n    }\n    return item;\n}\nfunction putLookup(lookup, key, value) {\n    value.next = lookup[key];\n    lookup[key] = value;\n}\nfunction disposeLookup(lookup) {\n    let updated = 0;\n    for (const p in lookup) {\n        let item = lookup[p];\n        while (item) {\n            updated = 1;\n            disposeBlock(item);\n            item = item.next;\n        }\n    }\n    return updated;\n}\n\n/**\n * Adds given element as a named ref\n */\nfunction setRef(host, key, elem) {\n    elem.setAttribute(getRefAttr(key, host), '');\n    host.refs[key] = elem;\n}\n/**\n * Removes ref for given key\n */\nfunction removeRef(host, key) {\n    // NB: Do not remove ref attribute in order to keep CSS styles for animated\n    // ref’ed element (`animate:out`). In case if its introduces unexpected side\n    // effects, update compiler to properly unmount refs but keep HTML attribute\n    // for animated elements\n    // const elem = host.refs[key];\n    // if (elem) {\n    // \telem.removeAttribute(getRefAttr(key, host));\n    // }\n    host.refs[key] = null;\n}\nfunction setPendingRef(pending, key, elem) {\n    if (key && elem) {\n        pending[key] = elem;\n    }\n}\nfunction finalizePendingRefs(host, pending) {\n    for (const key in pending) {\n        const prev = host.refs[key];\n        const next = pending[key];\n        if (prev !== next) {\n            prev && removeRef(host, key);\n            next && setRef(host, key, next);\n        }\n        pending[key] = null;\n    }\n}\n/**\n * Returns attribute name to identify element in CSS\n */\nfunction getRefAttr(name, host) {\n    const cssScope = host.componentModel.definition.cssScope;\n    return 'ref-' + name + (cssScope ? '-' + cssScope : '');\n}\n\n/**\n * Renders code, returned from `get` function, as HTML\n */\nfunction mountInnerHTML(host, injector, get, slotName) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        code: null,\n        slotName\n    });\n    updateInnerHTML(block);\n    return block;\n}\n/**\n * Updates inner HTML of block, defined in `ctx`\n * @returns Returns `1` if inner HTML was updated, `0` otherwise\n */\nfunction updateInnerHTML(block) {\n    const { host, injector, scope } = block;\n    const code = block.get(host, scope);\n    if (code !== block.code) {\n        emptyBlockContent(block);\n        if (isDefined(block.code = code)) {\n            injector.ptr = block.start;\n            renderHTML(host, injector, code, block.slotName);\n        }\n        injector.ptr = block.end;\n        return 1;\n    }\n    return 0;\n}\nfunction unmountInnerHTML(block) {\n    disposeBlock(block);\n}\nfunction clearInnerHTML(block) {\n    disposeBlock(block, true);\n}\nfunction renderHTML(host, injector, code, slotName) {\n    const { cssScope } = host.componentModel.definition;\n    if (isNode(code)) {\n        // Insert as DOM element\n        cssScope && scopeDOM(code, cssScope);\n        if (code.nodeType === code.DOCUMENT_FRAGMENT_NODE) {\n            // Insert document fragment contents separately to properly maintain\n            // list of inserted elements\n            while (code.firstChild) {\n                insert(injector, code.firstChild, slotName);\n            }\n        }\n        else {\n            insert(injector, code, slotName);\n        }\n    }\n    else {\n        // Render as HTML\n        const div = document.createElement('div');\n        div.innerHTML = code;\n        cssScope && scopeDOM(div, cssScope);\n        while (div.firstChild) {\n            insert(injector, div.firstChild, slotName);\n        }\n    }\n}\n/**\n * Scopes CSS of all elements in given node\n */\nfunction scopeDOM(node, cssScope) {\n    node = node.firstChild;\n    while (node) {\n        if (node.nodeType === node.ELEMENT_NODE) {\n            isolateElement(node, cssScope);\n            scopeDOM(node, cssScope);\n        }\n        node = node.nextSibling;\n    }\n}\nfunction isNode(obj) {\n    return obj && obj.nodeType;\n}\n\nfunction getPartial(host, name, componentPartials) {\n    return host.props['partial:' + name] || componentPartials[name];\n}\n/**\n * Mounts given partial into injector context\n */\nfunction mountPartial(host, injector, partial, args) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        mount: void 0,\n        update: void 0,\n        partial: null\n    });\n    updatePartial(block, partial, args);\n    return block;\n}\n/**\n * Updates mounted partial\n * @returns Returns `1` if partial was updated, `0` otherwise\n */\nfunction updatePartial(block, partial, args) {\n    const host = partial.host || block.host;\n    const { injector } = block;\n    const prevHost = block.host;\n    const prevScope = getScope(host);\n    let updated = 0;\n    block.host = host;\n    if (block.partial !== partial) {\n        // Unmount previously rendered partial\n        block.partial && emptyBlockContent(block);\n        // Mount new partial\n        const scope = block.scope = assign(obj(prevScope), partial.defaults, args);\n        setScope(host, scope);\n        injector.ptr = block.start;\n        block.mount = partial && partial.body;\n        block.update = block.mount && block.mount(host, injector, scope);\n        block.partial = partial;\n        setScope(host, prevScope);\n        updated = 1;\n    }\n    else if (block.update) {\n        // Update rendered partial\n        const scope = setScope(host, assign(block.scope, args));\n        if (block.update(host, scope)) {\n            updated = 1;\n        }\n        setScope(host, prevScope);\n    }\n    block.host = prevHost;\n    injector.ptr = block.end;\n    return updated;\n}\nfunction unmountPartial(block) {\n    disposeBlock(block);\n}\nfunction clearPartial(block) {\n    disposeBlock(block, true);\n}\n\nconst prefix = '$';\nclass Store {\n    constructor(data) {\n        this.sync = false;\n        this.listeners = [];\n        this.data = assign({}, data || {});\n    }\n    /**\n     * Returns current store data\n     */\n    get() {\n        return this.data;\n    }\n    /**\n     * Updates data in store\n     */\n    set(data) {\n        const updated = changed(data, this.data, prefix);\n        const render = this.sync ? renderComponent : scheduleRender;\n        if (updated) {\n            const next = this.data = assign(this.data, data);\n            // Notify listeners.\n            // Run in reverse order for listener safety (in case if handler decides\n            // to unsubscribe during notification)\n            for (let i = this.listeners.length - 1, item; i >= 0; i--) {\n                item = this.listeners[i];\n                if (!item.keys || !item.keys.length || hasChange(item.keys, updated)) {\n                    if ('component' in item) {\n                        render(item.component, updated);\n                    }\n                    else if ('handler' in item) {\n                        item.handler(next, updated);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Subscribes to changes in given store\n     * @param handler Function to invoke when store changes\n     * @param keys Run handler only if given top-level keys are changed\n     * @returns Object that should be used to unsubscribe from updates\n     */\n    subscribe(handler, keys) {\n        const obj = {\n            handler,\n            keys: scopeKeys(keys, prefix)\n        };\n        this.listeners.push(obj);\n        return obj;\n    }\n    /**\n     * Unsubscribes from further updates\n     */\n    unsubscribe(obj) {\n        const ix = this.listeners.indexOf(obj);\n        if (ix !== -1) {\n            this.listeners.splice(ix, 1);\n        }\n    }\n    /**\n     * Watches for updates of given `keys` in store and runs `component` render on change\n     */\n    watch(component, keys) {\n        this.listeners.push({\n            component,\n            keys: scopeKeys(keys, prefix)\n        });\n    }\n    /**\n     * Stops watching for store updates for given component\n     * @param {Component} component\n     */\n    unwatch(component) {\n        for (let i = 0; i < this.listeners.length; i++) {\n            if (this.listeners[i].component === component) {\n                this.listeners.splice(i, 1);\n            }\n        }\n    }\n}\n/**\n * Check if any of `keys` was changed in `next` object since `prev` state\n * @param {string[]} keys\n * @param {Object} updated\n * @return {boolean}\n */\nfunction hasChange(keys, updated) {\n    for (let i = 0; i < keys.length; i++) {\n        if (keys[i] in updated) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Adds given prefix to keys\n */\nfunction scopeKeys(keys, pfx) {\n    return keys && pfx ? keys.map(key => pfx + key) : keys;\n}\n\nconst pool = [];\nconst defaultTween = {\n    duration: 500,\n    delay: 0,\n    easing(t, b, c, d) {\n        return c * t / d + b;\n    }\n};\n// If `true` then no animations will be invoked\nlet blocked = false;\n/**\n * Starts animation on given element\n */\nfunction animate(elem, animation, callback) {\n    if (!blocked && animation) {\n        if (typeof animation === 'function') {\n            tweenAnimate(elem, animation, callback);\n        }\n        else {\n            cssAnimate(elem, animation, callback);\n        }\n    }\n    else if (callback) {\n        // Stop previous animation, if any\n        stopAnimation(elem, true);\n        callback();\n    }\n}\n/**\n * Starts CSS animation on given element\n */\nfunction cssAnimate(elem, animation, callback) {\n    // Stop previous animation, if any\n    stopAnimation(elem, true);\n    let timer;\n    const prevAnimation = elem.style.animation;\n    const evtPayload = {\n        animation,\n        direction: callback ? 'out' : 'in'\n    };\n    elem[animatingKey] = (cancel) => {\n        clearTimeout(timer);\n        elem.removeEventListener('animationend', handler);\n        elem.removeEventListener('animationcancel', handler);\n        elem.style.animation = prevAnimation;\n        notifyAnimation(elem, 'end', evtPayload);\n        !cancel && finalizeAnimation(callback);\n    };\n    const handler = (evt) => evt.target === elem && stopAnimation(elem);\n    elem.addEventListener('animationend', handler);\n    elem.addEventListener('animationcancel', handler);\n    elem.style.animation = animation;\n    // In case if callback is provided, we have to ensure that animation is actually applied.\n    // In some testing environments, animations could be disabled via\n    // `* { animation: none !important; }`. In this case, we should complete animation ASAP.\n    if (callback) {\n        nextTick(() => {\n            const style = window.getComputedStyle(elem, null);\n            if (!style.animationName || style.animationName === 'none') {\n                stopAnimation(elem);\n            }\n            else {\n                // Handle edge case: animation runs but during animation parent\n                // element is unmounted. In this case `animationend` callback won’t\n                // fire, causing memory leak.\n                // Create timer which will forcibly dispose animation after animation\n                // duration\n                const duration = parseDuration(style.animationDelay) + parseDuration(style.animationDuration);\n                if (duration) {\n                    timer = window.setTimeout(() => stopAnimation(elem), duration);\n                }\n            }\n        });\n    }\n    notifyAnimation(elem, 'start', evtPayload);\n}\n/**\n * Starts JS animation on given element\n */\nfunction tweenAnimate(elem, animation, callback) {\n    // Stop previous animation, if any\n    const prevAnim = findTween(elem);\n    stopAnimation(elem, true);\n    let options = animation(elem);\n    if (options) {\n        options = assign({}, defaultTween, options);\n        if (typeof options.easing !== 'function') {\n            throw new Error('Easing must be a function');\n        }\n        const now = performance.now();\n        const offset = prevAnim\n            ? 1 - (now - prevAnim.start) / (prevAnim.end - prevAnim.start)\n            : 0;\n        const start = now + options.delay - (offset * options.duration);\n        const anim = {\n            elem,\n            options,\n            start,\n            end: start + options.duration,\n            started: false\n        };\n        const evtPayload = {\n            animation,\n            tween: options,\n            direction: callback ? 'out' : 'in'\n        };\n        pool.push(anim);\n        elem[animatingKey] = (cancel) => {\n            pool.splice(pool.indexOf(anim), 1);\n            options.complete && options.complete(elem, options);\n            notifyAnimation(elem, 'end', evtPayload);\n            !cancel && finalizeAnimation(callback);\n        };\n        if (pool.length === 1) {\n            tweenLoop(now);\n        }\n        notifyAnimation(elem, 'start', evtPayload);\n    }\n    else if (callback) {\n        callback();\n    }\n}\n/**\n * Creates animation CSS value with scoped animation name\n */\nfunction createAnimation(animation, cssScope) {\n    if (animation == null) {\n        return '';\n    }\n    const parts = String(animation).split(' ');\n    const name = parts[0].trim();\n    const globalPrefix = 'global:';\n    if (name.indexOf(globalPrefix) === 0) {\n        // Do not scope animation name, use globally defined animation name\n        parts[0] = name.slice(globalPrefix.length);\n    }\n    else if (cssScope) {\n        parts[0] = concat(name, cssScope);\n    }\n    return parts.join(' ').trim();\n}\n/**\n * Composes two tween options objects into single one: instead of simple `assign`,\n * callbacks from both tweens will be composed into a single call\n */\nfunction composeTween(tween1, tween2) {\n    const next = assign({}, tween1, tween2);\n    const callbacks = ['start', 'step', 'complete'];\n    for (let i = 0; i < callbacks.length; i++) {\n        const cbName = callbacks[i];\n        const cb1 = tween1 && tween1[cbName];\n        const cb2 = tween2 && tween2[cbName];\n        if (cb1 && cb2) {\n            next[cbName] = (elem, p1, p2) => {\n                cb1(elem, p1, p2);\n                cb2(elem, p1, p2);\n            };\n        }\n    }\n    return next;\n}\n/**\n * Finalizes current animation: invokes given callback and blocks all nested\n * animations\n */\nfunction finalizeAnimation(callback) {\n    if (callback) {\n        blocked = true;\n        safeCall(callback);\n        blocked = false;\n    }\n}\nfunction tweenLoop(now) {\n    for (let i = pool.length - 1, anim; i >= 0; i--) {\n        anim = pool[i];\n        const { elem, options } = anim;\n        if (now >= anim.start) {\n            if (!anim.started) {\n                anim.started = true;\n                options.start && options.start(elem, options);\n            }\n            const finished = now >= anim.end;\n            const pos = finished ? 1 : options.easing(now - anim.start, 0, 1, options.duration);\n            options.step && options.step(elem, pos, options);\n            if (finished) {\n                stopAnimation(elem);\n            }\n        }\n    }\n    if (pool.length) {\n        requestAnimationFrame(tweenLoop);\n    }\n}\nfunction stopAnimation(elem, cancel) {\n    const callback = elem && elem[animatingKey];\n    if (callback) {\n        elem[animatingKey] = null;\n        callback(cancel);\n    }\n}\n/**\n * Finds existing tween animation for given element, if any\n */\nfunction findTween(elem) {\n    for (let i = 0; i < pool.length; i++) {\n        if (pool[i].elem === elem) {\n            return pool[i];\n        }\n    }\n    return null;\n}\n/**\n * Concatenates two strings with optional separator\n */\nfunction concat(name, suffix) {\n    const sep = suffix[0] === '_' || suffix[0] === '-' ? '' : '-';\n    return name + sep + suffix;\n}\nfunction nextTick(fn) {\n    if (typeof Promise !== 'undefined') {\n        Promise.resolve().then(fn);\n    }\n    else {\n        requestAnimationFrame(fn);\n    }\n}\nfunction notifyAnimation(elem, stage, detail) {\n    try {\n        elem.dispatchEvent(new CustomEvent(`animate-${stage}`, {\n            bubbles: false,\n            cancelable: false,\n            detail\n        }));\n    }\n    catch (err) {\n        // pass\n    }\n}\nfunction parseDuration(value) {\n    if (!value) {\n        return 0;\n    }\n    const ms = value.indexOf('ms') !== -1 ? 1 : 1000;\n    return parseFloat(value) * ms;\n}\n\n/**\n * Creates Endorphin component and mounts it into given `options.target` container\n */\nfunction endorphin(name, definition, options = {}) {\n    const component = createComponent(name, definition, options.target);\n    if (options.store) {\n        component.store = options.store;\n    }\n    if (options.target && !options.detached) {\n        options.target.appendChild(component);\n    }\n    mountComponent(component, options.props);\n    return component;\n}\n/**\n * Safe property getter\n * @param {*} ctx\n * @param {*} ...args\n * @returns {*}\n */\nfunction get(ctx) {\n    const hasMap = typeof Map !== 'undefined';\n    for (let i = 1, il = arguments.length, arg; ctx != null && i < il; i++) {\n        arg = arguments[i];\n        if (hasMap && ctx instanceof Map) {\n            ctx = ctx.get(arg);\n        }\n        else {\n            ctx = ctx[arg];\n        }\n    }\n    return ctx;\n}\n/**\n * Invokes `methodName` of `ctx` object with given args\n */\nfunction call(ctx, methodName, args) {\n    const method = ctx != null && ctx[methodName];\n    if (typeof method === 'function') {\n        return args ? method.apply(ctx, args) : method.call(ctx);\n    }\n}\n/**\n * Filter items from given collection that matches `fn` criteria and returns\n * matched items\n */\nfunction filter(collection, fn) {\n    const result = [];\n    if (collection && collection.forEach) {\n        collection.forEach((value, key) => {\n            if (fn(value, key)) {\n                result.push(value);\n            }\n        });\n    }\n    return result;\n}\n/**\n * Finds first item in given `collection` that matches truth test of `fn`\n */\nfunction find(collection, fn) {\n    if (Array.isArray(collection)) {\n        // Fast path: find item in array\n        for (let i = 0, item; i < collection.length; i++) {\n            item = collection[i];\n            if (fn(item, i)) {\n                return item;\n            }\n        }\n    }\n    else if (collection && collection.forEach) {\n        // Iterate over collection\n        let found = false;\n        let result = null;\n        collection.forEach((value, key) => {\n            if (!found && fn(value, key)) {\n                found = true;\n                result = value;\n            }\n        });\n        return result;\n    }\n}\n\nexport default endorphin;\nexport { Store, addEvent, addPendingClass, addPendingClassIf, animate, appendChild, assign, call, classNames, clearBlock, clearInnerHTML, clearIterator, clearKeyIterator, clearPartial, composeTween, createAnimation, createComponent, createComponentFromElement, createInjector, createScope, createSlot, cssAnimate, detachPendingEvents, disposeBlock, domInsert, domRemove, elem, elemNS, elemNSWithText, elemWithText, emptyBlockContent, enterScope, exitScope, filter, finalizeAttributes, finalizePendingEvents, finalizePendingRefs, find, get, getPartial, getProp, getScope, getSlotContext, getState, getVar, injectBlock, inputValue, insert, isolateElement, mountBlock, mountComponent, mountInnerHTML, mountIterator, mountKeyIterator, mountPartial, mountSlot, move, notifySlotUpdate, obj, pendingEvents, prepareScope, propsSet, removeEvent, removeRef, renderComponent, safeEventListener, scheduleRender, setAttribute, setAttributeExpression, setAttributeExpressionNS, setAttributeNS, setClass, setPendingAttributeNS, setPendingEvent, setPendingRef, setRef, setScope, setVar, stopAnimation, subscribeStore, text, tweenAnimate, unmountBlock, unmountComponent, unmountInnerHTML, unmountIterator, unmountKeyIterator, unmountPartial, unmountSlot, updateAttribute, updateAttributeNS, updateBlock, updateClass, updateComponent, updateDefaultSlot, updateIncomingSlot, updateInnerHTML, updateIterator, updateKeyIterator, updatePartial, updatePendingAttribute, updatePendingAttributeNS, updateProperty, updateText };\n//# sourceMappingURL=runtime.es.js.map\n",null,"<link rel=\"stylesheet\" href=\"./rod-app.scss\" />\n<script src=\"./rod-app.ts\"></script>\n\n<template>\n    Hello world!<br/>\n    <button on:click={onClick}>Click me</button>\n\t<p>Clicked { #count } { #count !== 1 ? 'times' : 'time' }</p>\n</template>",null],"names":["appendChild","element","node","elem","tagName","cssScope","el","document","createElement","setAttribute","isolateElement","text","value","textNode","$value","createTextNode","updateText","nodeValue","obj","proto","Object","create","isDefined","assign","target","source","i","arguments","length","p","hasOwnProperty","getObjectDescriptors","descriptors","props","getOwnPropertyNames","prop","descriptor","getOwnPropertyDescriptor","captureError","host","fn","arg1","arg2","error","runtimeError","console","CustomEvent","dispatchEvent","bubbles","cancelable","detail","handleEvent","event","this","listener","scope","safeEventListener","handler","call","setAttributeExpression","name","primitive","Array","isArray","representedValue","removeAttribute","uniqueClassFilter","cl","index","arr","indexOf","runHook","component","plugins","componentModel","hook","getScope","vars","renderQueue","attributeLookup","createComponent","definition","root","state","extend","events","collectPlugins","dest","push","dfn","methods","getDescriptors","createEventsMap","attachEventHandlers","prepare","refs","componentView","setProps","mounted","changes","setPropsInternal","preparing","scheduleRender","renderComponent","renderNext","setState","prev","next","hasChanges","addPropsState","defineProperties","store","input","parentNode","head","ptr","slots","update","queued","partialDeps","defaultProps","createComponentFromElement","requestAnimationFrame","drainQueue","arg","kebabCase","ch","toLowerCase","nextProps","current","str","String","split","filter","join","test","normalizeAttribute","listeners","evt","handlers","type","eventMap","names","keys","addEventListener","pending","attr","replace","onClick","count","elemWithText","binding","registerBinding","removeEventListener","options","detached","ctx","default","mountComponent","endorphin","log","nodeName","body"],"mappings":"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"}